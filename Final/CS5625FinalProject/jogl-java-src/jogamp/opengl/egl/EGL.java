/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Thu Nov 01 02:15:24 CET 2012 ----! */

package jogamp.opengl.egl;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.opengl.GLProcAddressResolver;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class EGL {

  /** Part of khronos_boolean_enum_t<br>Defined as part of enum type "khronos_boolean_enum_t" */
  public static final int KHRONOS_FALSE = 0;
  /** Part of khronos_boolean_enum_t<br>Defined as part of enum type "khronos_boolean_enum_t" */
  public static final int KHRONOS_TRUE = 1;
  /** Part of khronos_boolean_enum_t<br>Defined as part of enum type "khronos_boolean_enum_t" */
  public static final long KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 2147483647;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_FALSE = 0;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRUE = 1;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SUCCESS = 0x3000;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NOT_INITIALIZED = 0x3001;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_ACCESS = 0x3002;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_ALLOC = 0x3003;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_ATTRIBUTE = 0x3004;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_CONFIG = 0x3005;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_CONTEXT = 0x3006;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_CURRENT_SURFACE = 0x3007;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_DISPLAY = 0x3008;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_MATCH = 0x3009;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_NATIVE_PIXMAP = 0x300A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_NATIVE_WINDOW = 0x300B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_PARAMETER = 0x300C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BAD_SURFACE = 0x300D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONTEXT_LOST = 0x300E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BUFFER_SIZE = 0x3020;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_SIZE = 0x3021;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BLUE_SIZE = 0x3022;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_GREEN_SIZE = 0x3023;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_RED_SIZE = 0x3024;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_DEPTH_SIZE = 0x3025;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_STENCIL_SIZE = 0x3026;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONFIG_CAVEAT = 0x3027;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONFIG_ID = 0x3028;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_LEVEL = 0x3029;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MAX_PBUFFER_HEIGHT = 0x302A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MAX_PBUFFER_PIXELS = 0x302B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MAX_PBUFFER_WIDTH = 0x302C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NATIVE_RENDERABLE = 0x302D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NATIVE_VISUAL_ID = 0x302E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NATIVE_VISUAL_TYPE = 0x302F;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SAMPLES = 0x3031;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SAMPLE_BUFFERS = 0x3032;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SURFACE_TYPE = 0x3033;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_TYPE = 0x3034;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_BLUE_VALUE = 0x3035;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_GREEN_VALUE = 0x3036;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_RED_VALUE = 0x3037;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NONE = 0x3038;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BIND_TO_TEXTURE_RGB = 0x3039;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BIND_TO_TEXTURE_RGBA = 0x303A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MIN_SWAP_INTERVAL = 0x303B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MAX_SWAP_INTERVAL = 0x303C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_LUMINANCE_SIZE = 0x303D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_MASK_SIZE = 0x303E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_COLOR_BUFFER_TYPE = 0x303F;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_RENDERABLE_TYPE = 0x3040;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MATCH_NATIVE_PIXMAP = 0x3041;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONFORMANT = 0x3042;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SLOW_CONFIG = 0x3050;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NON_CONFORMANT_CONFIG = 0x3051;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TRANSPARENT_RGB = 0x3052;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_RGB_BUFFER = 0x308E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_LUMINANCE_BUFFER = 0x308F;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_NO_TEXTURE = 0x305C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_RGB = 0x305D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_RGBA = 0x305E;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_2D = 0x305F;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_PBUFFER_BIT = 0x0001;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_PIXMAP_BIT = 0x0002;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_WINDOW_BIT = 0x0004;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_COLORSPACE_LINEAR_BIT = 0x0020;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_ALPHA_FORMAT_PRE_BIT = 0x0040;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MULTISAMPLE_RESOLVE_BOX_BIT = 0x0200;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SWAP_BEHAVIOR_PRESERVED_BIT = 0x0400;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_ES_BIT = 0x0001;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENVG_BIT = 0x0002;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_ES2_BIT = 0x0004;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_BIT = 0x0008;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VENDOR = 0x3053;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VERSION = 0x3054;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_EXTENSIONS = 0x3055;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CLIENT_APIS = 0x308D;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_HEIGHT = 0x3056;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_WIDTH = 0x3057;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_LARGEST_PBUFFER = 0x3058;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_FORMAT = 0x3080;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_TEXTURE_TARGET = 0x3081;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MIPMAP_TEXTURE = 0x3082;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MIPMAP_LEVEL = 0x3083;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_RENDER_BUFFER = 0x3086;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_COLORSPACE = 0x3087;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_ALPHA_FORMAT = 0x3088;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_HORIZONTAL_RESOLUTION = 0x3090;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VERTICAL_RESOLUTION = 0x3091;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_PIXEL_ASPECT_RATIO = 0x3092;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SWAP_BEHAVIOR = 0x3093;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MULTISAMPLE_RESOLVE = 0x3099;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BACK_BUFFER = 0x3084;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_SINGLE_BUFFER = 0x3085;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_COLORSPACE_sRGB = 0x3089;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_COLORSPACE_LINEAR = 0x308A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_ALPHA_FORMAT_NONPRE = 0x308B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_VG_ALPHA_FORMAT_PRE = 0x308C;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_DISPLAY_SCALING = 10000;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BUFFER_PRESERVED = 0x3094;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_BUFFER_DESTROYED = 0x3095;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENVG_IMAGE = 0x3096;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONTEXT_CLIENT_TYPE = 0x3097;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MULTISAMPLE_RESOLVE_DEFAULT = 0x309A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_MULTISAMPLE_RESOLVE_BOX = 0x309B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_ES_API = 0x30A0;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENVG_API = 0x30A1;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_OPENGL_API = 0x30A2;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_DRAW = 0x3059;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_READ = 0x305A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_CORE_NATIVE_ENGINE = 0x305B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_COLORSPACE = 0x3087;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_FORMAT = 0x3088;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_COLORSPACE_sRGB = 0x3089;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_COLORSPACE_LINEAR = 0x308A;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_FORMAT_NONPRE = 0x308B;
  /** Part of <code>EGL_VERSION_1_X</code> */
  public static final int EGL_ALPHA_FORMAT_PRE = 0x308C;

  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglBindAPI(int api)  {

    final long __addr_ = _table._addressof_eglBindAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglBindAPI\" not available");
    }
        return dispatch_eglBindAPI0(api, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindAPI(EGLenum api); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglBindAPI0(int api, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglBindTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _table._addressof_eglBindTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglBindTexImage\" not available");
    }
        return dispatch_eglBindTexImage0(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglBindTexImage0(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglChooseConfig(long dpy, IntBuffer attrib_list, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    if (!Buffers.isDirect(configs))
      throw new RuntimeException("Argument \"configs\" is not a direct buffer");
    if (!Buffers.isDirect(num_config))
      throw new RuntimeException("Argument \"num_config\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglChooseConfig;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglChooseConfig\" not available");
    }
        return dispatch_eglChooseConfig0(dpy, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), configs != null ? configs.getBuffer() : null, Buffers.getDirectBufferByteOffset(configs), config_size, num_config, Buffers.getDirectBufferByteOffset(num_config), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglChooseConfig(EGLDisplay dpy, const EGLint *  attrib_list, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglChooseConfig0(long dpy, Object attrib_list, int attrib_list_byte_offset, Object configs, int configs_byte_offset, int config_size, Object num_config, int num_config_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglCopyBuffers(long dpy, long surface, long target)  {

    final long __addr_ = _table._addressof_eglCopyBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCopyBuffers\" not available");
    }
        return dispatch_eglCopyBuffers0(dpy, surface, target, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglCopyBuffers0(long dpy, long surface, long target, long procAddress);

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreateContext(long dpy, long config, long share_context, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateContext\" not available");
    }
        return dispatch_eglCreateContext0(dpy, config, share_context, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreateContext0(long dpy, long config, long share_context, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreatePbufferFromClientBuffer(long dpy, int buftype, Buffer buffer, long config, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(buffer))
      throw new RuntimeException("Argument \"buffer\" is not a direct buffer");
    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePbufferFromClientBuffer;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePbufferFromClientBuffer\" not available");
    }
        return dispatch_eglCreatePbufferFromClientBuffer0(dpy, buftype, buffer, Buffers.getDirectBufferByteOffset(buffer), config, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param buffer a direct only {@link java.nio.Buffer}
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreatePbufferFromClientBuffer0(long dpy, int buftype, Object buffer, int buffer_byte_offset, long config, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreatePbufferSurface(long dpy, long config, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePbufferSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePbufferSurface\" not available");
    }
        return dispatch_eglCreatePbufferSurface0(dpy, config, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreatePbufferSurface0(long dpy, long config, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreatePixmapSurface(long dpy, long config, long pixmap, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreatePixmapSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreatePixmapSurface\" not available");
    }
        return dispatch_eglCreatePixmapSurface0(dpy, config, pixmap, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreatePixmapSurface0(long dpy, long config, long pixmap, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static long eglCreateWindowSurface(long dpy, long config, long win, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new RuntimeException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglCreateWindowSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglCreateWindowSurface\" not available");
    }
        return dispatch_eglCreateWindowSurface0(dpy, config, win, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *  attrib_list); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_eglCreateWindowSurface0(long dpy, long config, long win, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglDestroyContext(long dpy, long ctx)  {

    final long __addr_ = _table._addressof_eglDestroyContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglDestroyContext\" not available");
    }
        return dispatch_eglDestroyContext0(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroyContext(EGLDisplay dpy, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglDestroyContext0(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglDestroySurface(long dpy, long surface)  {

    final long __addr_ = _table._addressof_eglDestroySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglDestroySurface\" not available");
    }
        return dispatch_eglDestroySurface0(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglDestroySurface0(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglGetConfigAttrib(long dpy, long config, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetConfigAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigAttrib\" not available");
    }
        return dispatch_eglGetConfigAttrib0(dpy, config, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglGetConfigAttrib0(long dpy, long config, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglGetConfigs(long dpy, PointerBuffer configs, int config_size, IntBuffer num_config)  {

    if (!Buffers.isDirect(configs))
      throw new RuntimeException("Argument \"configs\" is not a direct buffer");
    if (!Buffers.isDirect(num_config))
      throw new RuntimeException("Argument \"num_config\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglGetConfigs;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetConfigs\" not available");
    }
        return dispatch_eglGetConfigs0(dpy, configs != null ? configs.getBuffer() : null, Buffers.getDirectBufferByteOffset(configs), config_size, num_config, Buffers.getDirectBufferByteOffset(num_config), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglGetConfigs(EGLDisplay dpy, EGLConfig *  configs, EGLint config_size, EGLint *  num_config); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param configs a direct only {@link com.jogamp.common.nio.PointerBuffer}
      @param num_config a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglGetConfigs0(long dpy, Object configs, int configs_byte_offset, int config_size, Object num_config, int num_config_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetCurrentContext()  {

    final long __addr_ = _table._addressof_eglGetCurrentContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetCurrentContext\" not available");
    }
        return dispatch_eglGetCurrentContext0(__addr_);
  }

  /** Entry point to C language function: <code> EGLContext eglGetCurrentContext(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetCurrentContext0(long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetCurrentDisplay()  {

    final long __addr_ = _table._addressof_eglGetCurrentDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetCurrentDisplay\" not available");
    }
        return dispatch_eglGetCurrentDisplay0(__addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetCurrentDisplay(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetCurrentDisplay0(long procAddress);

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetCurrentSurface(int readdraw)  {

    final long __addr_ = _table._addressof_eglGetCurrentSurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetCurrentSurface\" not available");
    }
        return dispatch_eglGetCurrentSurface0(readdraw, __addr_);
  }

  /** Entry point to C language function: <code> EGLSurface eglGetCurrentSurface(EGLint readdraw); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetCurrentSurface0(int readdraw, long procAddress);

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetDisplay(long display_id)  {

    final long __addr_ = _table._addressof_eglGetDisplay;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetDisplay\" not available");
    }
        return dispatch_eglGetDisplay0(display_id, __addr_);
  }

  /** Entry point to C language function: <code> EGLDisplay eglGetDisplay(EGLNativeDisplayType display_id); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetDisplay0(long display_id, long procAddress);

  /** Entry point to C language function: <code> EGLint eglGetError(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static int eglGetError()  {

    final long __addr_ = _table._addressof_eglGetError;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetError\" not available");
    }
        return dispatch_eglGetError0(__addr_);
  }

  /** Entry point to C language function: <code> EGLint eglGetError(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native int dispatch_eglGetError0(long procAddress);

  /** Entry point to C language function: <code> __EGLFuncPtr eglGetProcAddress(const char *  procname); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static long eglGetProcAddress(String procname)  {

    final long __addr_ = _table._addressof_eglGetProcAddress;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglGetProcAddress\" not available");
    }
        return dispatch_eglGetProcAddress0(procname, __addr_);
  }

  /** Entry point to C language function: <code> __EGLFuncPtr eglGetProcAddress(const char *  procname); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native long dispatch_eglGetProcAddress0(String procname, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param major a direct only {@link java.nio.IntBuffer}
      @param minor a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglInitialize(long dpy, IntBuffer major, IntBuffer minor)  {

    if (!Buffers.isDirect(major))
      throw new RuntimeException("Argument \"major\" is not a direct buffer");
    if (!Buffers.isDirect(minor))
      throw new RuntimeException("Argument \"minor\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglInitialize;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglInitialize\" not available");
    }
        return dispatch_eglInitialize0(dpy, major, Buffers.getDirectBufferByteOffset(major), minor, Buffers.getDirectBufferByteOffset(minor), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *  major, EGLint *  minor); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param major a direct only {@link java.nio.IntBuffer}
      @param minor a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglInitialize0(long dpy, Object major, int major_byte_offset, Object minor, int minor_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglMakeCurrent(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = _table._addressof_eglMakeCurrent;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglMakeCurrent\" not available");
    }
        return dispatch_eglMakeCurrent0(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglMakeCurrent0(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> EGLenum eglQueryAPI(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static int eglQueryAPI()  {

    final long __addr_ = _table._addressof_eglQueryAPI;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryAPI\" not available");
    }
        return dispatch_eglQueryAPI0(__addr_);
  }

  /** Entry point to C language function: <code> EGLenum eglQueryAPI(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native int dispatch_eglQueryAPI0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglQueryContext(long dpy, long ctx, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQueryContext;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryContext\" not available");
    }
        return dispatch_eglQueryContext0(dpy, ctx, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglQueryContext0(long dpy, long ctx, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static String eglQueryString(long dpy, int name)  {

    final long __addr_ = _table._addressof_eglQueryString;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQueryString\" not available");
    }
        return dispatch_eglQueryString0(dpy, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  eglQueryString(EGLDisplay dpy, EGLint name); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native String dispatch_eglQueryString0(long dpy, int name, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static boolean eglQuerySurface(long dpy, long surface, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new RuntimeException("Argument \"value\" is not a direct buffer");
    final long __addr_ = _table._addressof_eglQuerySurface;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglQuerySurface\" not available");
    }
        return dispatch_eglQuerySurface0(dpy, surface, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *  value); </code> <br>Part of <code>EGL_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_eglQuerySurface0(long dpy, long surface, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglReleaseTexImage(long dpy, long surface, int buffer)  {

    final long __addr_ = _table._addressof_eglReleaseTexImage;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglReleaseTexImage\" not available");
    }
        return dispatch_eglReleaseTexImage0(dpy, surface, buffer, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglReleaseTexImage0(long dpy, long surface, int buffer, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglReleaseThread()  {

    final long __addr_ = _table._addressof_eglReleaseThread;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglReleaseThread\" not available");
    }
        return dispatch_eglReleaseThread0(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglReleaseThread(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglReleaseThread0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglSurfaceAttrib(long dpy, long surface, int attribute, int value)  {

    final long __addr_ = _table._addressof_eglSurfaceAttrib;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSurfaceAttrib\" not available");
    }
        return dispatch_eglSurfaceAttrib0(dpy, surface, attribute, value, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglSurfaceAttrib0(long dpy, long surface, int attribute, int value, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglSwapBuffers(long dpy, long surface)  {

    final long __addr_ = _table._addressof_eglSwapBuffers;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSwapBuffers\" not available");
    }
        return dispatch_eglSwapBuffers0(dpy, surface, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglSwapBuffers0(long dpy, long surface, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglSwapInterval(long dpy, int interval)  {

    final long __addr_ = _table._addressof_eglSwapInterval;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglSwapInterval\" not available");
    }
        return dispatch_eglSwapInterval0(dpy, interval, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglSwapInterval(EGLDisplay dpy, EGLint interval); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglSwapInterval0(long dpy, int interval, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglTerminate(long dpy)  {

    final long __addr_ = _table._addressof_eglTerminate;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglTerminate\" not available");
    }
        return dispatch_eglTerminate0(dpy, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglTerminate(EGLDisplay dpy); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglTerminate0(long dpy, long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglWaitClient()  {

    final long __addr_ = _table._addressof_eglWaitClient;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglWaitClient\" not available");
    }
        return dispatch_eglWaitClient0(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitClient(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglWaitClient0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglWaitGL()  {

    final long __addr_ = _table._addressof_eglWaitGL;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglWaitGL\" not available");
    }
        return dispatch_eglWaitGL0(__addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitGL(void); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglWaitGL0(long procAddress);

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static boolean eglWaitNative(int engine)  {

    final long __addr_ = _table._addressof_eglWaitNative;
    if (__addr_ == 0) {
      throw new UnsupportedOperationException("Method \"eglWaitNative\" not available");
    }
        return dispatch_eglWaitNative0(engine, __addr_);
  }

  /** Entry point to C language function: <code> EGLBoolean eglWaitNative(EGLint engine); </code> <br>Part of <code>EGL_VERSION_1_X</code>   */
  public static native boolean dispatch_eglWaitNative0(int engine, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  private static EGLProcAddressTable _table = new EGLProcAddressTable(new GLProcAddressResolver());
  public static void resetProcAddressTable(DynamicLookupHelper lookup) {
      _table.reset(lookup);
  }
  public static final long EGL_DEFAULT_DISPLAY = 0;
  public static final long EGL_NO_CONTEXT = 0;
  public static final long EGL_NO_DISPLAY = 0;
  public static final long EGL_NO_SURFACE = 0;
  public static final int  EGL_DONT_CARE  = -1;
  public static final int  EGL_UNKNOWN    = -1;
 
  protected static long eglGetProcAddress(long eglGetProcAddressHandle, java.lang.String procname)
  {
    if (eglGetProcAddressHandle == 0) {
      throw new GLException("Passed null pointer for method \"eglGetProcAddress\"");
    }
    return dispatch_eglGetProcAddress0(procname, eglGetProcAddressHandle);
  }
  // ---- End CustomJavaCode .cfg declarations

} // end of class EGL
