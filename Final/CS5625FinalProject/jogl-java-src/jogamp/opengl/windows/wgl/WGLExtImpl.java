/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Thu Nov 01 02:15:58 CET 2012 ----! */

package jogamp.opengl.windows.wgl;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class WGLExtImpl implements WGLExt{
  /** Entry point to C language function: <code> LPVOID wglAllocateMemoryNV(GLsizei, GLfloat, GLfloat, GLfloat); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>   */
  public ByteBuffer wglAllocateMemoryNV(int arg0, float arg1, float arg2, float arg3)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglAllocateMemoryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglAllocateMemoryNV\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_wglAllocateMemoryNV0(arg0, arg1, arg2, arg3, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> LPVOID wglAllocateMemoryNV(GLsizei, GLfloat, GLfloat, GLfloat); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>   */
  private native ByteBuffer dispatch_wglAllocateMemoryNV0(int arg0, float arg1, float arg2, float arg3, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBeginFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public boolean wglBeginFrameTrackingI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBeginFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglBeginFrameTrackingI3D\" not available");
    }
        return dispatch_wglBeginFrameTrackingI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBeginFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public native boolean dispatch_wglBeginFrameTrackingI3D0(long procAddress);

  /** Entry point to C language function: <code> GLboolean wglBindDisplayColorTableEXT(GLushort); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public boolean wglBindDisplayColorTableEXT(short arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglBindDisplayColorTableEXT\" not available");
    }
        return dispatch_wglBindDisplayColorTableEXT0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglBindDisplayColorTableEXT(GLushort); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public native boolean dispatch_wglBindDisplayColorTableEXT0(short arg0, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindSwapBarrierNV(GLuint group, GLuint barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglBindSwapBarrierNV(int group, int barrier)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindSwapBarrierNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglBindSwapBarrierNV\" not available");
    }
        return dispatch_wglBindSwapBarrierNV0(group, barrier, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindSwapBarrierNV(GLuint group, GLuint barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public native boolean dispatch_wglBindSwapBarrierNV0(int group, int barrier, long procAddress);

  /** Entry point to C language function: <code> BOOL wglBindTexImageARB(HANDLE, int); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public boolean wglBindTexImageARB(long arg0, int arg1)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglBindTexImageARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglBindTexImageARB\" not available");
    }
        return dispatch_wglBindTexImageARB0(arg0, arg1, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglBindTexImageARB(HANDLE, int); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public native boolean dispatch_wglBindTexImageARB0(long arg0, int arg1, long procAddress);

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatARB(HANDLE, const int * , const FLOAT * , UINT, int * , UINT * ); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param arg1 a direct only {@link java.nio.IntBuffer}
      @param arg2 a direct only {@link java.nio.FloatBuffer}
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}   */
  public boolean wglChoosePixelFormatARB(long arg0, IntBuffer arg1, FloatBuffer arg2, int arg3, IntBuffer arg4, IntBuffer arg5)  {

    if (!Buffers.isDirect(arg1))
      throw new GLException("Argument \"arg1\" is not a direct buffer");
    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglChoosePixelFormatARB\" not available");
    }
        return dispatch_wglChoosePixelFormatARB0(arg0, arg1, Buffers.getDirectBufferByteOffset(arg1), arg2, Buffers.getDirectBufferByteOffset(arg2), arg3, arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatARB(HANDLE, const int * , const FLOAT * , UINT, int * , UINT * ); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param arg1 a direct only {@link java.nio.IntBuffer}
      @param arg2 a direct only {@link java.nio.FloatBuffer}
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglChoosePixelFormatARB0(long arg0, Object arg1, int arg1_byte_offset, Object arg2, int arg2_byte_offset, int arg3, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatEXT(HANDLE, const int * , const FLOAT * , UINT, int * , UINT * ); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param arg1 a direct only {@link java.nio.IntBuffer}
      @param arg2 a direct only {@link java.nio.FloatBuffer}
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}   */
  public boolean wglChoosePixelFormatEXT(long arg0, IntBuffer arg1, FloatBuffer arg2, int arg3, IntBuffer arg4, IntBuffer arg5)  {

    if (!Buffers.isDirect(arg1))
      throw new GLException("Argument \"arg1\" is not a direct buffer");
    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglChoosePixelFormatEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglChoosePixelFormatEXT\" not available");
    }
        return dispatch_wglChoosePixelFormatEXT0(arg0, arg1, Buffers.getDirectBufferByteOffset(arg1), arg2, Buffers.getDirectBufferByteOffset(arg2), arg3, arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglChoosePixelFormatEXT(HANDLE, const int * , const FLOAT * , UINT, int * , UINT * ); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param arg1 a direct only {@link java.nio.IntBuffer}
      @param arg2 a direct only {@link java.nio.FloatBuffer}
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglChoosePixelFormatEXT0(long arg0, Object arg1, int arg1_byte_offset, Object arg2, int arg2_byte_offset, int arg3, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreateBufferRegionARB(HANDLE, int, UINT); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public long wglCreateBufferRegionARB(long arg0, int arg1, int arg2)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreateBufferRegionARB\" not available");
    }
        return dispatch_wglCreateBufferRegionARB0(arg0, arg1, arg2, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateBufferRegionARB(HANDLE, int, UINT); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public native long dispatch_wglCreateBufferRegionARB0(long arg0, int arg1, int arg2, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreateContextAttribsARB(HANDLE hDC, HANDLE hshareContext, const int *  attribList); </code> <br>Part of <code>WGL_ARB_create_context</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  public long wglCreateContextAttribsARB(long hDC, long hshareContext, IntBuffer attribList)  {

    if (!Buffers.isDirect(attribList))
      throw new GLException("Argument \"attribList\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreateContextAttribsARB\" not available");
    }
        return dispatch_wglCreateContextAttribsARB0(hDC, hshareContext, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreateContextAttribsARB(HANDLE hDC, HANDLE hshareContext, const int *  attribList); </code> <br>Part of <code>WGL_ARB_create_context</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreateContextAttribsARB0(long hDC, long hshareContext, Object attribList, int attribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLboolean wglCreateDisplayColorTableEXT(GLushort); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public boolean wglCreateDisplayColorTableEXT(short arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreateDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreateDisplayColorTableEXT\" not available");
    }
        return dispatch_wglCreateDisplayColorTableEXT0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglCreateDisplayColorTableEXT(GLushort); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public native boolean dispatch_wglCreateDisplayColorTableEXT0(short arg0, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferARB(HANDLE, int, int, int, const int * ); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}   */
  public long wglCreatePbufferARB(long arg0, int arg1, int arg2, int arg3, IntBuffer arg4)  {

    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreatePbufferARB\" not available");
    }
        return dispatch_wglCreatePbufferARB0(arg0, arg1, arg2, arg3, arg4, Buffers.getDirectBufferByteOffset(arg4), __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferARB(HANDLE, int, int, int, const int * ); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreatePbufferARB0(long arg0, int arg1, int arg2, int arg3, Object arg4, int arg4_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferEXT(HANDLE, int, int, int, const int * ); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}   */
  public long wglCreatePbufferEXT(long arg0, int arg1, int arg2, int arg3, IntBuffer arg4)  {

    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglCreatePbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglCreatePbufferEXT\" not available");
    }
        return dispatch_wglCreatePbufferEXT0(arg0, arg1, arg2, arg3, arg4, Buffers.getDirectBufferByteOffset(arg4), __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglCreatePbufferEXT(HANDLE, int, int, int, const int * ); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_wglCreatePbufferEXT0(long arg0, int arg1, int arg2, int arg3, Object arg4, int arg4_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void wglDeleteBufferRegionARB(HANDLE); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public void wglDeleteBufferRegionARB(long arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDeleteBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDeleteBufferRegionARB\" not available");
    }
        dispatch_wglDeleteBufferRegionARB0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> void wglDeleteBufferRegionARB(HANDLE); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public native void dispatch_wglDeleteBufferRegionARB0(long arg0, long procAddress);

  /** Entry point to C language function: <code> void wglDestroyDisplayColorTableEXT(GLushort); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public void wglDestroyDisplayColorTableEXT(short arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDestroyDisplayColorTableEXT\" not available");
    }
        dispatch_wglDestroyDisplayColorTableEXT0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> void wglDestroyDisplayColorTableEXT(GLushort); </code> <br>Part of <code>WGL_EXT_display_color_table</code>   */
  public native void dispatch_wglDestroyDisplayColorTableEXT0(short arg0, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferARB(HANDLE); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public boolean wglDestroyPbufferARB(long arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyPbufferARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDestroyPbufferARB\" not available");
    }
        return dispatch_wglDestroyPbufferARB0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferARB(HANDLE); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public native boolean dispatch_wglDestroyPbufferARB0(long arg0, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferEXT(HANDLE); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public boolean wglDestroyPbufferEXT(long arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDestroyPbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDestroyPbufferEXT\" not available");
    }
        return dispatch_wglDestroyPbufferEXT0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDestroyPbufferEXT(HANDLE); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public native boolean dispatch_wglDestroyPbufferEXT0(long arg0, long procAddress);

  /** Entry point to C language function: <code> BOOL wglDisableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public boolean wglDisableFrameLockI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglDisableFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglDisableFrameLockI3D\" not available");
    }
        return dispatch_wglDisableFrameLockI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglDisableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public native boolean dispatch_wglDisableFrameLockI3D0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglEnableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public boolean wglEnableFrameLockI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEnableFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglEnableFrameLockI3D\" not available");
    }
        return dispatch_wglEnableFrameLockI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglEnableFrameLockI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>   */
  public native boolean dispatch_wglEnableFrameLockI3D0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglEndFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public boolean wglEndFrameTrackingI3D()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglEndFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglEndFrameTrackingI3D\" not available");
    }
        return dispatch_wglEndFrameTrackingI3D0(__addr_);
  }

  /** Entry point to C language function: <code> BOOL wglEndFrameTrackingI3D(void); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>   */
  public native boolean dispatch_wglEndFrameTrackingI3D0(long procAddress);

  /** Entry point to C language function: <code> void wglFreeMemoryNV(LPVOID); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>
      @param arg0 a direct only {@link java.nio.Buffer}   */
  public void wglFreeMemoryNV(Buffer arg0)  {

    if (!Buffers.isDirect(arg0))
      throw new GLException("Argument \"arg0\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglFreeMemoryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglFreeMemoryNV\" not available");
    }
        dispatch_wglFreeMemoryNV0(arg0, Buffers.getDirectBufferByteOffset(arg0), __addr_);
  }

  /** Entry point to C language function: <code> void wglFreeMemoryNV(LPVOID); </code> <br>Part of <code>WGL_NV_vertex_array_range</code>
      @param arg0 a direct only {@link java.nio.Buffer}   */
  private native void dispatch_wglFreeMemoryNV0(Object arg0, int arg0_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglGetCurrentReadDCARB(void); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public long wglGetCurrentReadDC()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetCurrentReadDC;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetCurrentReadDC\" not available");
    }
        return dispatch_wglGetCurrentReadDC0(__addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetCurrentReadDCARB(void); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public native long dispatch_wglGetCurrentReadDC0(long procAddress);

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringARB(HANDLE); </code> <br>Part of <code>WGL_ARB_extensions_string</code>   */
  public String wglGetExtensionsStringARB(long arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetExtensionsStringARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetExtensionsStringARB\" not available");
    }
        return dispatch_wglGetExtensionsStringARB0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringARB(HANDLE); </code> <br>Part of <code>WGL_ARB_extensions_string</code>   */
  public native String dispatch_wglGetExtensionsStringARB0(long arg0, long procAddress);

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringEXT(void); </code> <br>Part of <code>WGL_EXT_extensions_string</code>   */
  public String wglGetExtensionsStringEXT()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetExtensionsStringEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetExtensionsStringEXT\" not available");
    }
        return dispatch_wglGetExtensionsStringEXT0(__addr_);
  }

  /** Entry point to C language function: <code> LPCSTR wglGetExtensionsStringEXT(void); </code> <br>Part of <code>WGL_EXT_extensions_string</code>   */
  public native String dispatch_wglGetExtensionsStringEXT0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetFrameUsageI3D(float * ); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param arg0 a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglGetFrameUsageI3D(FloatBuffer arg0)  {

    if (!Buffers.isDirect(arg0))
      throw new GLException("Argument \"arg0\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetFrameUsageI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetFrameUsageI3D\" not available");
    }
        return dispatch_wglGetFrameUsageI3D0(arg0, Buffers.getDirectBufferByteOffset(arg0), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetFrameUsageI3D(float * ); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param arg0 a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetFrameUsageI3D0(Object arg0, int arg0_byte_offset, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCARB(HANDLE); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public long wglGetPbufferDCARB(long arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPbufferDCARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPbufferDCARB\" not available");
    }
        return dispatch_wglGetPbufferDCARB0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCARB(HANDLE); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public native long dispatch_wglGetPbufferDCARB0(long arg0, long procAddress);

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCEXT(HANDLE); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public long wglGetPbufferDCEXT(long arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPbufferDCEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPbufferDCEXT\" not available");
    }
        return dispatch_wglGetPbufferDCEXT0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> HANDLE wglGetPbufferDCEXT(HANDLE); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public native long dispatch_wglGetPbufferDCEXT0(long arg0, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvARB(HANDLE, int, int, UINT, const int * , FLOAT * ); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglGetPixelFormatAttribfvARB(long arg0, int arg1, int arg2, int arg3, IntBuffer arg4, FloatBuffer arg5)  {

    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribfvARB\" not available");
    }
        return dispatch_wglGetPixelFormatAttribfvARB0(arg0, arg1, arg2, arg3, arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvARB(HANDLE, int, int, UINT, const int * , FLOAT * ); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribfvARB0(long arg0, int arg1, int arg2, int arg3, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvEXT(HANDLE, int, int, UINT, int * , FLOAT * ); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglGetPixelFormatAttribfvEXT(long arg0, int arg1, int arg2, int arg3, IntBuffer arg4, FloatBuffer arg5)  {

    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribfvEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribfvEXT\" not available");
    }
        return dispatch_wglGetPixelFormatAttribfvEXT0(arg0, arg1, arg2, arg3, arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribfvEXT(HANDLE, int, int, UINT, int * , FLOAT * ); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribfvEXT0(long arg0, int arg1, int arg2, int arg3, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivARB(HANDLE, int, int, UINT, const int * , int * ); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}   */
  public boolean wglGetPixelFormatAttribivARB(long arg0, int arg1, int arg2, int arg3, IntBuffer arg4, IntBuffer arg5)  {

    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribivARB\" not available");
    }
        return dispatch_wglGetPixelFormatAttribivARB0(arg0, arg1, arg2, arg3, arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivARB(HANDLE, int, int, UINT, const int * , int * ); </code> <br>Part of <code>WGL_ARB_pixel_format</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribivARB0(long arg0, int arg1, int arg2, int arg3, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivEXT(HANDLE, int, int, UINT, int * , int * ); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}   */
  public boolean wglGetPixelFormatAttribivEXT(long arg0, int arg1, int arg2, int arg3, IntBuffer arg4, IntBuffer arg5)  {

    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetPixelFormatAttribivEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetPixelFormatAttribivEXT\" not available");
    }
        return dispatch_wglGetPixelFormatAttribivEXT0(arg0, arg1, arg2, arg3, arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglGetPixelFormatAttribivEXT(HANDLE, int, int, UINT, int * , int * ); </code> <br>Part of <code>WGL_EXT_pixel_format</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglGetPixelFormatAttribivEXT0(long arg0, int arg1, int arg2, int arg3, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int wglGetSwapIntervalEXT(void); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public int wglGetSwapIntervalEXT()  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglGetSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglGetSwapIntervalEXT\" not available");
    }
        return dispatch_wglGetSwapIntervalEXT0(__addr_);
  }

  /** Entry point to C language function: <code> int wglGetSwapIntervalEXT(void); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public native int dispatch_wglGetSwapIntervalEXT0(long procAddress);

  /** Entry point to C language function: <code> BOOL wglIsEnabledFrameLockI3D(BOOL * ); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param arg0 a direct only {@link java.nio.ByteBuffer}   */
  public boolean wglIsEnabledFrameLockI3D(ByteBuffer arg0)  {

    if (!Buffers.isDirect(arg0))
      throw new GLException("Argument \"arg0\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglIsEnabledFrameLockI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglIsEnabledFrameLockI3D\" not available");
    }
        return dispatch_wglIsEnabledFrameLockI3D0(arg0, Buffers.getDirectBufferByteOffset(arg0), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglIsEnabledFrameLockI3D(BOOL * ); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param arg0 a direct only {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_wglIsEnabledFrameLockI3D0(Object arg0, int arg0_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglJoinSwapGroupNV(HANDLE hDC, GLuint group); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglJoinSwapGroupNV(long hDC, int group)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglJoinSwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglJoinSwapGroupNV\" not available");
    }
        return dispatch_wglJoinSwapGroupNV0(hDC, group, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglJoinSwapGroupNV(HANDLE hDC, GLuint group); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public native boolean dispatch_wglJoinSwapGroupNV0(long hDC, int group, long procAddress);

  /** Entry point to C language function: <code> GLboolean wglLoadDisplayColorTableEXT(const GLushort * , GLuint); </code> <br>Part of <code>WGL_EXT_display_color_table</code>
      @param arg0 a direct only {@link java.nio.ShortBuffer}   */
  public boolean wglLoadDisplayColorTableEXT(ShortBuffer arg0, int arg1)  {

    if (!Buffers.isDirect(arg0))
      throw new GLException("Argument \"arg0\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglLoadDisplayColorTableEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglLoadDisplayColorTableEXT\" not available");
    }
        return dispatch_wglLoadDisplayColorTableEXT0(arg0, Buffers.getDirectBufferByteOffset(arg0), arg1, __addr_);
  }

  /** Entry point to C language function: <code> GLboolean wglLoadDisplayColorTableEXT(const GLushort * , GLuint); </code> <br>Part of <code>WGL_EXT_display_color_table</code>
      @param arg0 a direct only {@link java.nio.ShortBuffer}   */
  private native boolean dispatch_wglLoadDisplayColorTableEXT0(Object arg0, int arg0_byte_offset, int arg1, long procAddress);

  /** Entry point to C language function: <code> BOOL wglMakeContextCurrentARB(HANDLE, HANDLE, HANDLE); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public boolean wglMakeContextCurrent(long arg0, long arg1, long arg2)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglMakeContextCurrent;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglMakeContextCurrent\" not available");
    }
        return dispatch_wglMakeContextCurrent0(arg0, arg1, arg2, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglMakeContextCurrentARB(HANDLE, HANDLE, HANDLE); </code> <br>Part of <code>WGL_ARB_make_current_read</code>   */
  public native boolean dispatch_wglMakeContextCurrent0(long arg0, long arg1, long arg2, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameCountNV(HANDLE hDC, GLuint *  count); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryFrameCountNV(long hDC, IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryFrameCountNV\" not available");
    }
        return dispatch_wglQueryFrameCountNV0(hDC, count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameCountNV(HANDLE hDC, GLuint *  count); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryFrameCountNV0(long hDC, Object count, int count_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameLockMasterI3D(BOOL * ); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param arg0 a direct only {@link java.nio.ByteBuffer}   */
  public boolean wglQueryFrameLockMasterI3D(ByteBuffer arg0)  {

    if (!Buffers.isDirect(arg0))
      throw new GLException("Argument \"arg0\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameLockMasterI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryFrameLockMasterI3D\" not available");
    }
        return dispatch_wglQueryFrameLockMasterI3D0(arg0, Buffers.getDirectBufferByteOffset(arg0), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameLockMasterI3D(BOOL * ); </code> <br>Part of <code>WGL_I3D_swap_frame_lock</code>
      @param arg0 a direct only {@link java.nio.ByteBuffer}   */
  private native boolean dispatch_wglQueryFrameLockMasterI3D0(Object arg0, int arg0_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryFrameTrackingI3D(DWORD * , DWORD * , float * ); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param arg0 a direct only {@link java.nio.IntBuffer}
      @param arg1 a direct only {@link java.nio.IntBuffer}
      @param arg2 a direct only {@link java.nio.FloatBuffer}   */
  public boolean wglQueryFrameTrackingI3D(IntBuffer arg0, IntBuffer arg1, FloatBuffer arg2)  {

    if (!Buffers.isDirect(arg0))
      throw new GLException("Argument \"arg0\" is not a direct buffer");
    if (!Buffers.isDirect(arg1))
      throw new GLException("Argument \"arg1\" is not a direct buffer");
    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryFrameTrackingI3D;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryFrameTrackingI3D\" not available");
    }
        return dispatch_wglQueryFrameTrackingI3D0(arg0, Buffers.getDirectBufferByteOffset(arg0), arg1, Buffers.getDirectBufferByteOffset(arg1), arg2, Buffers.getDirectBufferByteOffset(arg2), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryFrameTrackingI3D(DWORD * , DWORD * , float * ); </code> <br>Part of <code>WGL_I3D_swap_frame_usage</code>
      @param arg0 a direct only {@link java.nio.IntBuffer}
      @param arg1 a direct only {@link java.nio.IntBuffer}
      @param arg2 a direct only {@link java.nio.FloatBuffer}   */
  private native boolean dispatch_wglQueryFrameTrackingI3D0(Object arg0, int arg0_byte_offset, Object arg1, int arg1_byte_offset, Object arg2, int arg2_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryMaxSwapGroupsNV(HANDLE hDC, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryMaxSwapGroupsNV(long hDC, IntBuffer maxGroups, IntBuffer maxBarriers)  {

    if (!Buffers.isDirect(maxGroups))
      throw new GLException("Argument \"maxGroups\" is not a direct buffer");
    if (!Buffers.isDirect(maxBarriers))
      throw new GLException("Argument \"maxBarriers\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryMaxSwapGroupsNV\" not available");
    }
        return dispatch_wglQueryMaxSwapGroupsNV0(hDC, maxGroups, Buffers.getDirectBufferByteOffset(maxGroups), maxBarriers, Buffers.getDirectBufferByteOffset(maxBarriers), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryMaxSwapGroupsNV(HANDLE hDC, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryMaxSwapGroupsNV0(long hDC, Object maxGroups, int maxGroups_byte_offset, Object maxBarriers, int maxBarriers_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryPbufferARB(HANDLE, int, int * ); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryPbufferARB(long arg0, int arg1, IntBuffer arg2)  {

    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryPbufferARB\" not available");
    }
        return dispatch_wglQueryPbufferARB0(arg0, arg1, arg2, Buffers.getDirectBufferByteOffset(arg2), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferARB(HANDLE, int, int * ); </code> <br>Part of <code>WGL_ARB_pbuffer</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryPbufferARB0(long arg0, int arg1, Object arg2, int arg2_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQueryPbufferEXT(HANDLE, int, int * ); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQueryPbufferEXT(long arg0, int arg1, IntBuffer arg2)  {

    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQueryPbufferEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQueryPbufferEXT\" not available");
    }
        return dispatch_wglQueryPbufferEXT0(arg0, arg1, arg2, Buffers.getDirectBufferByteOffset(arg2), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQueryPbufferEXT(HANDLE, int, int * ); </code> <br>Part of <code>WGL_EXT_pbuffer</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQueryPbufferEXT0(long arg0, int arg1, Object arg2, int arg2_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglQuerySwapGroupNV(HANDLE hDC, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  public boolean wglQuerySwapGroupNV(long hDC, IntBuffer group, IntBuffer barrier)  {

    if (!Buffers.isDirect(group))
      throw new GLException("Argument \"group\" is not a direct buffer");
    if (!Buffers.isDirect(barrier))
      throw new GLException("Argument \"barrier\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglQuerySwapGroupNV\" not available");
    }
        return dispatch_wglQuerySwapGroupNV0(hDC, group, Buffers.getDirectBufferByteOffset(group), barrier, Buffers.getDirectBufferByteOffset(barrier), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglQuerySwapGroupNV(HANDLE hDC, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>WGL_NV_swap_group</code>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglQuerySwapGroupNV0(long hDC, Object group, int group_byte_offset, Object barrier, int barrier_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int wglReleasePbufferDCARB(HANDLE, HANDLE); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public int wglReleasePbufferDCARB(long arg0, long arg1)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleasePbufferDCARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglReleasePbufferDCARB\" not available");
    }
        return dispatch_wglReleasePbufferDCARB0(arg0, arg1, __addr_);
  }

  /** Entry point to C language function: <code> int wglReleasePbufferDCARB(HANDLE, HANDLE); </code> <br>Part of <code>WGL_ARB_pbuffer</code>   */
  public native int dispatch_wglReleasePbufferDCARB0(long arg0, long arg1, long procAddress);

  /** Entry point to C language function: <code> int wglReleasePbufferDCEXT(HANDLE, HANDLE); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public int wglReleasePbufferDCEXT(long arg0, long arg1)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleasePbufferDCEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglReleasePbufferDCEXT\" not available");
    }
        return dispatch_wglReleasePbufferDCEXT0(arg0, arg1, __addr_);
  }

  /** Entry point to C language function: <code> int wglReleasePbufferDCEXT(HANDLE, HANDLE); </code> <br>Part of <code>WGL_EXT_pbuffer</code>   */
  public native int dispatch_wglReleasePbufferDCEXT0(long arg0, long arg1, long procAddress);

  /** Entry point to C language function: <code> BOOL wglReleaseTexImageARB(HANDLE, int); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public boolean wglReleaseTexImageARB(long arg0, int arg1)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglReleaseTexImageARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglReleaseTexImageARB\" not available");
    }
        return dispatch_wglReleaseTexImageARB0(arg0, arg1, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglReleaseTexImageARB(HANDLE, int); </code> <br>Part of <code>WGL_ARB_render_texture</code>   */
  public native boolean dispatch_wglReleaseTexImageARB0(long arg0, int arg1, long procAddress);

  /** Entry point to C language function: <code> BOOL wglResetFrameCountNV(HANDLE hDC); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public boolean wglResetFrameCountNV(long hDC)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglResetFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglResetFrameCountNV\" not available");
    }
        return dispatch_wglResetFrameCountNV0(hDC, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglResetFrameCountNV(HANDLE hDC); </code> <br>Part of <code>WGL_NV_swap_group</code>   */
  public native boolean dispatch_wglResetFrameCountNV0(long hDC, long procAddress);

  /** Entry point to C language function: <code> BOOL wglRestoreBufferRegionARB(HANDLE, int, int, int, int, int, int); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public boolean wglRestoreBufferRegionARB(long arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglRestoreBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglRestoreBufferRegionARB\" not available");
    }
        return dispatch_wglRestoreBufferRegionARB0(arg0, arg1, arg2, arg3, arg4, arg5, arg6, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglRestoreBufferRegionARB(HANDLE, int, int, int, int, int, int); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public native boolean dispatch_wglRestoreBufferRegionARB0(long arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSaveBufferRegionARB(HANDLE, int, int, int, int); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public boolean wglSaveBufferRegionARB(long arg0, int arg1, int arg2, int arg3, int arg4)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSaveBufferRegionARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglSaveBufferRegionARB\" not available");
    }
        return dispatch_wglSaveBufferRegionARB0(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSaveBufferRegionARB(HANDLE, int, int, int, int); </code> <br>Part of <code>WGL_ARB_buffer_region</code>   */
  public native boolean dispatch_wglSaveBufferRegionARB0(long arg0, int arg1, int arg2, int arg3, int arg4, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSetPbufferAttribARB(HANDLE, const int * ); </code> <br>Part of <code>WGL_ARB_render_texture</code>
      @param arg1 a direct only {@link java.nio.IntBuffer}   */
  public boolean wglSetPbufferAttribARB(long arg0, IntBuffer arg1)  {

    if (!Buffers.isDirect(arg1))
      throw new GLException("Argument \"arg1\" is not a direct buffer");
    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSetPbufferAttribARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglSetPbufferAttribARB\" not available");
    }
        return dispatch_wglSetPbufferAttribARB0(arg0, arg1, Buffers.getDirectBufferByteOffset(arg1), __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSetPbufferAttribARB(HANDLE, const int * ); </code> <br>Part of <code>WGL_ARB_render_texture</code>
      @param arg1 a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_wglSetPbufferAttribARB0(long arg0, Object arg1, int arg1_byte_offset, long procAddress);

  /** Entry point to C language function: <code> BOOL wglSwapIntervalEXT(int); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public boolean wglSwapIntervalEXT(int arg0)  {

    final long __addr_ = _context.getWGLExtProcAddressTable()._addressof_wglSwapIntervalEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"wglSwapIntervalEXT\" not available");
    }
        return dispatch_wglSwapIntervalEXT0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> BOOL wglSwapIntervalEXT(int); </code> <br>Part of <code>WGL_EXT_swap_control</code>   */
  public native boolean dispatch_wglSwapIntervalEXT0(int arg0, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public WGLExtImpl(WindowsWGLContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private WindowsWGLContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class WGLExtImpl
