/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Thu Nov 01 02:15:35 CET 2012 ----! */

package jogamp.opengl.x11.glx;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import jogamp.nativewindow.x11.*;
import com.jogamp.gluegen.runtime.opengl.GLProcAddressResolver;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

 /**
  * Provides access to the X11-specific OpenGL vendor extensions.
  * See {@link GLBase} for more information.
  */
public class GLX {

  /** Part of CORE DEF */
  public static final int HAS_STDDEF = 1;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_USE_GL = 1;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BUFFER_SIZE = 2;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_LEVEL = 3;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RGBA = 4;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DOUBLEBUFFER = 5;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STEREO = 6;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_AUX_BUFFERS = 7;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RED_SIZE = 8;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_GREEN_SIZE = 9;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BLUE_SIZE = 10;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ALPHA_SIZE = 11;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DEPTH_SIZE = 12;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STENCIL_SIZE = 13;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_RED_SIZE = 14;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_GREEN_SIZE = 15;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_BLUE_SIZE = 16;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_ALPHA_SIZE = 17;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_SCREEN = 1;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_ATTRIBUTE = 2;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_NO_EXTENSION = 3;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_VISUAL = 4;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_CONTEXT = 5;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_VALUE = 6;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BAD_ENUM = 7;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_VENDOR = 1;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_VERSION = 2;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_EXTENSIONS = 3;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_CONFIG_CAVEAT = 0x20;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final long GLX_DONT_CARE = 0xFFFFFFFF;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SLOW_CONFIG = 0x8001;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_NON_CONFORMANT_CONFIG = 0x800D;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_X_VISUAL_TYPE = 0x22;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_TYPE = 0x23;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_INDEX_VALUE = 0x24;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_RED_VALUE = 0x25;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_GREEN_VALUE = 0x26;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_BLUE_VALUE = 0x27;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_ALPHA_VALUE = 0x28;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_MAX_PBUFFER_WIDTH = 0x8016;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_MAX_PBUFFER_HEIGHT = 0x8017;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_MAX_PBUFFER_PIXELS = 0x8018;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PRESERVED_CONTENTS = 0x801B;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_LARGEST_PBUFFER = 0x801C;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_WIDTH = 0x801D;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_HEIGHT = 0x801E;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_EVENT_MASK = 0x801F;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DRAWABLE_TYPE = 0x8010;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_FBCONFIG_ID = 0x8013;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_VISUAL_ID = 0x800B;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_WINDOW_BIT = 0x00000001;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PIXMAP_BIT = 0x00000002;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER_BIT = 0x00000004;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_AUX_BUFFERS_BIT = 0x00000010;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_FRONT_LEFT_BUFFER_BIT = 0x00000001;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_FRONT_RIGHT_BUFFER_BIT = 0x00000002;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BACK_LEFT_BUFFER_BIT = 0x00000004;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_BACK_RIGHT_BUFFER_BIT = 0x00000008;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DEPTH_BUFFER_BIT = 0x00000020;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STENCIL_BUFFER_BIT = 0x00000040;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_ACCUM_BUFFER_BIT = 0x00000080;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RENDER_TYPE = 0x8011;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_X_RENDERABLE = 0x8012;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_NONE = 0x8000;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRUE_COLOR = 0x8002;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DIRECT_COLOR = 0x8003;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PSEUDO_COLOR = 0x8004;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STATIC_COLOR = 0x8005;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_GRAY_SCALE = 0x8006;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_STATIC_GRAY = 0x8007;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_RGB = 0x8008;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_TRANSPARENT_INDEX = 0x8009;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RGBA_TYPE = 0x8014;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_COLOR_INDEX_TYPE = 0x8015;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_COLOR_INDEX_BIT = 0x00000002;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_RGBA_BIT = 0x00000001;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SCREEN = 0x800C;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER_CLOBBER_MASK = 0x08000000;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_DAMAGED = 0x8020;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SAVED = 0x8021;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_WINDOW = 0x8022;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER = 0x8023;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER_HEIGHT = 0x8040;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_PBUFFER_WIDTH = 0x8041;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SAMPLE_BUFFERS = 0x186a0;
  /** Part of <code>GLX_VERSION_1_X</code> */
  public static final int GLX_SAMPLES = 0x186a1;
  /** Part of CORE DEF */
  public static final int GLX_VERSION_1_X = 1;
  /** Part of CORE DEF */
  public static final int GLX_GLXEXT_VERSION = 21;
  /** Part of <code>GLX_ARB_multisample</code> */
  public static final int GLX_SAMPLE_BUFFERS_ARB = 100000;
  /** Part of <code>GLX_ARB_multisample</code> */
  public static final int GLX_SAMPLES_ARB = 100001;
  /** Part of <code>GLX_ARB_fbconfig_float</code> */
  public static final int GLX_RGBA_FLOAT_TYPE_ARB = 0x20B9;
  /** Part of <code>GLX_ARB_fbconfig_float</code> */
  public static final int GLX_RGBA_FLOAT_BIT_ARB = 0x00000004;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_DEBUG_BIT_ARB = 0x00000001;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB = 0x00000002;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_CORE_PROFILE_BIT_ARB = 0x00000001;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB = 0x00000002;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_MAJOR_VERSION_ARB = 0x2091;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_MINOR_VERSION_ARB = 0x2092;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_FLAGS_ARB = 0x2094;
  /** Part of <code>GLX_ARB_create_context</code> */
  public static final int GLX_CONTEXT_PROFILE_MASK_ARB = 0x9126;
  /** Part of <code>GLX_ARB_create_context_robustness</code> */
  public static final int GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB = 0x00000004;
  /** Part of <code>GLX_ARB_create_context_robustness</code> */
  public static final int GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256;
  /** Part of <code>GLX_ARB_create_context_robustness</code> */
  public static final int GLX_NO_RESET_NOTIFICATION_ARB = 0x8261;
  /** Part of <code>GLX_ARB_create_context_robustness</code> */
  public static final int GLX_LOSE_CONTEXT_ON_RESET_ARB = 0x8252;
  /** Part of <code>GLX_EXT_create_context_es2_profile</code> */
  public static final int GLX_CONTEXT_ES2_PROFILE_BIT_EXT = 0x00000004;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_X_VISUAL_TYPE_EXT = 0x22;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_TYPE_EXT = 0x23;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_INDEX_VALUE_EXT = 0x24;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_RED_VALUE_EXT = 0x25;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_GREEN_VALUE_EXT = 0x26;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_BLUE_VALUE_EXT = 0x27;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_ALPHA_VALUE_EXT = 0x28;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_NONE_EXT = 0x8000;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRUE_COLOR_EXT = 0x8002;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_DIRECT_COLOR_EXT = 0x8003;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_PSEUDO_COLOR_EXT = 0x8004;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_STATIC_COLOR_EXT = 0x8005;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_GRAY_SCALE_EXT = 0x8006;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_STATIC_GRAY_EXT = 0x8007;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_RGB_EXT = 0x8008;
  /** Part of <code>GLX_GLXEXT_LEGACY</code>, <code>GLX_EXT_visual_info</code> */
  public static final int GLX_TRANSPARENT_INDEX_EXT = 0x8009;
  /** Part of <code>GLX_EXT_visual_rating</code> */
  public static final int GLX_VISUAL_CAVEAT_EXT = 0x20;
  /** Part of <code>GLX_EXT_visual_rating</code> */
  public static final int GLX_SLOW_VISUAL_EXT = 0x8001;
  /** Part of <code>GLX_EXT_visual_rating</code> */
  public static final int GLX_NON_CONFORMANT_VISUAL_EXT = 0x800D;
  /** Part of <code>GLX_EXT_import_context</code> */
  public static final int GLX_SHARE_CONTEXT_EXT = 0x800A;
  /** Part of <code>GLX_EXT_import_context</code> */
  public static final int GLX_VISUAL_ID_EXT = 0x800B;
  /** Part of <code>GLX_EXT_import_context</code> */
  public static final int GLX_SCREEN_EXT = 0x800C;
  /** Part of <code>GLX_OML_swap_method</code> */
  public static final int GLX_SWAP_METHOD_OML = 0x8060;
  /** Part of <code>GLX_OML_swap_method</code> */
  public static final int GLX_SWAP_EXCHANGE_OML = 0x8061;
  /** Part of <code>GLX_OML_swap_method</code> */
  public static final int GLX_SWAP_COPY_OML = 0x8062;
  /** Part of <code>GLX_OML_swap_method</code> */
  public static final int GLX_SWAP_UNDEFINED_OML = 0x8063;
  /** Part of CORE DEF */
  public static final int GLX_ARB_get_proc_address = 1;
  /** Part of <code>GLX_EXT_fbconfig_packed_float</code> */
  public static final int GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT = 0x20B1;
  /** Part of <code>GLX_EXT_fbconfig_packed_float</code> */
  public static final int GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT = 0x00000008;
  /** Part of <code>GLX_EXT_framebuffer_sRGB</code> */
  public static final int GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT = 0x20B2;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BIND_TO_TEXTURE_RGB_EXT = 0x20D0;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BIND_TO_TEXTURE_RGBA_EXT = 0x20D1;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BIND_TO_MIPMAP_TEXTURE_EXT = 0x20D2;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BIND_TO_TEXTURE_TARGETS_EXT = 0x20D3;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_Y_INVERTED_EXT = 0x20D4;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_FORMAT_EXT = 0x20D5;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_TARGET_EXT = 0x20D6;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_MIPMAP_TEXTURE_EXT = 0x20D7;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_FORMAT_NONE_EXT = 0x20D8;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_FORMAT_RGB_EXT = 0x20D9;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_FORMAT_RGBA_EXT = 0x20DA;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_1D_BIT_EXT = 0x00000001;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_2D_BIT_EXT = 0x00000002;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_RECTANGLE_BIT_EXT = 0x00000004;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_1D_EXT = 0x20DB;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_2D_EXT = 0x20DC;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_TEXTURE_RECTANGLE_EXT = 0x20DD;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_FRONT_LEFT_EXT = 0x20DE;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_FRONT_RIGHT_EXT = 0x20DF;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BACK_LEFT_EXT = 0x20E0;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BACK_RIGHT_EXT = 0x20E1;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_FRONT_EXT = 0x20DE;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_BACK_EXT = 0x20E0;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX0_EXT = 0x20E2;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX1_EXT = 0x20E3;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX2_EXT = 0x20E4;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX3_EXT = 0x20E5;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX4_EXT = 0x20E6;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX5_EXT = 0x20E7;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX6_EXT = 0x20E8;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX7_EXT = 0x20E9;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX8_EXT = 0x20EA;
  /** Part of <code>GLX_EXT_texture_from_pixmap</code> */
  public static final int GLX_AUX9_EXT = 0x20EB;
  /** Part of CORE DEF */
  public static final int GLX_ARB_multisample = 1;
  /** Part of CORE DEF */
  public static final int GLX_ARB_fbconfig_float = 1;
  /** Part of CORE DEF */
  public static final int GLX_ARB_create_context = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIS_multisample = 1;
  /** Part of <code>GLX_GLXEXT_LEGACY</code> */
  public static final int GLX_EXT_visual_info = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_swap_control = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGI_swap_control = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGI_video_sync = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGI_make_current_read = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_video_source = 1;
  /** Part of CORE DEF */
  public static final int GLX_EXT_visual_rating = 1;
  /** Part of CORE DEF */
  public static final int GLX_EXT_import_context = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_fbconfig = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_pbuffer = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGI_cushion = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_video_resize = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_dmbuffer = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_swap_group = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_swap_barrier = 1;
  /** Part of CORE DEF */
  public static final int GLX_SUN_get_transparent_index = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_copy_sub_buffer = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_pixmap_colormap = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_release_buffers = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_set_3dfx_mode = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_visual_select_group = 1;
  /** Part of CORE DEF */
  public static final int GLX_OML_swap_method = 1;
  /** Part of CORE DEF */
  public static final int GLX_OML_sync_control = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_float_buffer = 1;
  /** Part of CORE DEF */
  public static final int GLX_SGIX_hyperpipe = 1;
  /** Part of CORE DEF */
  public static final int GLX_MESA_agp_offset = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_vertex_array_range = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_swap_group = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_video_out = 1;
  /** Part of CORE DEF */
  public static final int GLX_EXT_fbconfig_packed_float = 1;
  /** Part of CORE DEF */
  public static final int GLX_EXT_framebuffer_sRGB = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_present_video = 1;
  /** Part of CORE DEF */
  public static final int GLX_NV_multisample_coverage = 1;

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public static void glXBindTexImageEXT(long dpy, long drawable, int buffer, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXBindTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindTexImageEXT\" not available");
    }
        dispatch_glXBindTexImageEXT0(dpy, drawable, buffer, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private static native void dispatch_glXBindTexImageEXT0(long dpy, long drawable, int buffer, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXCopyContext(Display *  dpy, GLXContext src, GLXContext dst, unsigned long mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXCopyContext(long dpy, long src, long dst, long mask)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCopyContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCopyContext\" not available");
    }
        dispatch_glXCopyContext0(dpy, src, dst, mask, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopyContext(Display *  dpy, GLXContext src, GLXContext dst, unsigned long mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXCopyContext0(long dpy, long src, long dst, long mask, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateContext(Display *  dpy, XVisualInfo *  vis, GLXContext shareList, Bool direct); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXCreateContext(long dpy, XVisualInfo vis, long shareList, boolean direct)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCreateContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateContext\" not available");
    }
        return dispatch_glXCreateContext0(dpy, ((vis == null) ? null : vis.getBuffer()), shareList, direct, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateContext(Display *  dpy, XVisualInfo *  vis, GLXContext shareList, Bool direct); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  private static native long dispatch_glXCreateContext0(long dpy, ByteBuffer vis, long shareList, boolean direct, long procAddress);

  /** Entry point to C language function: <code> XID glXCreateGLXPixmap(Display *  dpy, XVisualInfo *  visual, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXCreateGLXPixmap(long dpy, XVisualInfo visual, long pixmap)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCreateGLXPixmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateGLXPixmap\" not available");
    }
        return dispatch_glXCreateGLXPixmap0(dpy, ((visual == null) ? null : visual.getBuffer()), pixmap, __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreateGLXPixmap(Display *  dpy, XVisualInfo *  visual, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  private static native long dispatch_glXCreateGLXPixmap0(long dpy, ByteBuffer visual, long pixmap, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateNewContext(Display *  dpy, GLXFBConfig config, int renderType, GLXContext shareList, Bool direct); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXCreateNewContext(long dpy, long config, int renderType, long shareList, boolean direct)  {

    final long __addr_ = glxProcAddressTable._addressof_glXCreateNewContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateNewContext\" not available");
    }
        return dispatch_glXCreateNewContext0(dpy, config, renderType, shareList, direct, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateNewContext(Display *  dpy, GLXFBConfig config, int renderType, GLXContext shareList, Bool direct); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native long dispatch_glXCreateNewContext0(long dpy, long config, int renderType, long shareList, boolean direct, long procAddress);

  /** Entry point to C language function: <code> XID glXCreatePbuffer(Display *  dpy, GLXFBConfig config, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  public static long glXCreatePbuffer(long dpy, long config, IntBuffer attribList)  {

    if (!Buffers.isDirect(attribList))
      throw new GLException("Argument \"attribList\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXCreatePbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreatePbuffer\" not available");
    }
        return dispatch_glXCreatePbuffer0(dpy, config, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreatePbuffer(Display *  dpy, GLXFBConfig config, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_glXCreatePbuffer0(long dpy, long config, Object attribList, int attribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> XID glXCreatePixmap(Display *  dpy, GLXFBConfig config, XID pixmap, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  public static long glXCreatePixmap(long dpy, long config, long pixmap, IntBuffer attribList)  {

    if (!Buffers.isDirect(attribList))
      throw new GLException("Argument \"attribList\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXCreatePixmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreatePixmap\" not available");
    }
        return dispatch_glXCreatePixmap0(dpy, config, pixmap, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreatePixmap(Display *  dpy, GLXFBConfig config, XID pixmap, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_glXCreatePixmap0(long dpy, long config, long pixmap, Object attribList, int attribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> XID glXCreateWindow(Display *  dpy, GLXFBConfig config, XID win, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  public static long glXCreateWindow(long dpy, long config, long win, IntBuffer attribList)  {

    if (!Buffers.isDirect(attribList))
      throw new GLException("Argument \"attribList\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXCreateWindow;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateWindow\" not available");
    }
        return dispatch_glXCreateWindow0(dpy, config, win, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
  }

  /** Entry point to C language function: <code> XID glXCreateWindow(Display *  dpy, GLXFBConfig config, XID win, const int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param attribList a direct only {@link java.nio.IntBuffer}   */
  private static native long dispatch_glXCreateWindow0(long dpy, long config, long win, Object attribList, int attribList_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyContext(Display *  dpy, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyContext(long dpy, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyContext\" not available");
    }
        dispatch_glXDestroyContext0(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyContext(Display *  dpy, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyContext0(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyGLXPixmap(Display *  dpy, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyGLXPixmap(long dpy, long pixmap)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyGLXPixmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyGLXPixmap\" not available");
    }
        dispatch_glXDestroyGLXPixmap0(dpy, pixmap, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyGLXPixmap(Display *  dpy, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyGLXPixmap0(long dpy, long pixmap, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyPbuffer(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyPbuffer(long dpy, long pbuf)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyPbuffer;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyPbuffer\" not available");
    }
        dispatch_glXDestroyPbuffer0(dpy, pbuf, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyPbuffer(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyPbuffer0(long dpy, long pbuf, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyPixmap(Display *  dpy, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyPixmap(long dpy, long pixmap)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyPixmap;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyPixmap\" not available");
    }
        dispatch_glXDestroyPixmap0(dpy, pixmap, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyPixmap(Display *  dpy, XID pixmap); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyPixmap0(long dpy, long pixmap, long procAddress);

  /** Entry point to C language function: <code> void glXDestroyWindow(Display *  dpy, XID window); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXDestroyWindow(long dpy, long window)  {

    final long __addr_ = glxProcAddressTable._addressof_glXDestroyWindow;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXDestroyWindow\" not available");
    }
        dispatch_glXDestroyWindow0(dpy, window, __addr_);
  }

  /** Entry point to C language function: <code> void glXDestroyWindow(Display *  dpy, XID window); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXDestroyWindow0(long dpy, long window, long procAddress);

  /** Entry point to C language function: <code> const char *  glXGetClientString(Display *  dpy, int name); </code> <br>Part of CORE FUNC   */
  public static String glXGetClientString(long dpy, int name)  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetClientString;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetClientString\" not available");
    }
        return dispatch_glXGetClientString0(dpy, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXGetClientString(Display *  dpy, int name); </code> <br>Part of CORE FUNC   */
  public static native String dispatch_glXGetClientString0(long dpy, int name, long procAddress);

  /** Entry point to C language function: <code> int glXGetConfig(Display *  dpy, XVisualInfo *  visual, int attrib, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static int glXGetConfig(long dpy, XVisualInfo visual, int attrib, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXGetConfig;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetConfig\" not available");
    }
        return dispatch_glXGetConfig0(dpy, ((visual == null) ? null : visual.getBuffer()), attrib, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetConfig(Display *  dpy, XVisualInfo *  visual, int attrib, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native int dispatch_glXGetConfig0(long dpy, ByteBuffer visual, int attrib, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXGetCurrentContext(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXGetCurrentContext()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentContext\" not available");
    }
        return dispatch_glXGetCurrentContext0(__addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXGetCurrentContext(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native long dispatch_glXGetCurrentContext0(long procAddress);

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplay(void); </code> <br>Part of CORE FUNC   */
  public static long glXGetCurrentDisplay()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentDisplay;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentDisplay\" not available");
    }
        return dispatch_glXGetCurrentDisplay0(__addr_);
  }

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplay(void); </code> <br>Part of CORE FUNC   */
  public static native long dispatch_glXGetCurrentDisplay0(long procAddress);

  /** Entry point to C language function: <code> XID glXGetCurrentDrawable(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXGetCurrentDrawable()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentDrawable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentDrawable\" not available");
    }
        return dispatch_glXGetCurrentDrawable0(__addr_);
  }

  /** Entry point to C language function: <code> XID glXGetCurrentDrawable(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native long dispatch_glXGetCurrentDrawable0(long procAddress);

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawable(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static long glXGetCurrentReadDrawable()  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetCurrentReadDrawable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentReadDrawable\" not available");
    }
        return dispatch_glXGetCurrentReadDrawable0(__addr_);
  }

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawable(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native long dispatch_glXGetCurrentReadDrawable0(long procAddress);

  /** Entry point to C language function: <code> int glXGetFBConfigAttrib(Display *  dpy, GLXFBConfig config, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static int glXGetFBConfigAttrib(long dpy, long config, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXGetFBConfigAttrib;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetFBConfigAttrib\" not available");
    }
        return dispatch_glXGetFBConfigAttrib0(dpy, config, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetFBConfigAttrib(Display *  dpy, GLXFBConfig config, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native int dispatch_glXGetFBConfigAttrib0(long dpy, long config, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLXFBConfig *  glXGetFBConfigs(Display *  dpy, int screen, int *  nelements); </code> <br>Part of CORE FUNC
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  public static PointerBuffer glXGetFBConfigs(long dpy, int screen, IntBuffer nelements)  {

    if (!Buffers.isDirect(nelements))
      throw new GLException("Argument \"nelements\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXGetFBConfigs;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetFBConfigs\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glXGetFBConfigs0(dpy, screen, nelements, Buffers.getDirectBufferByteOffset(nelements), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return PointerBuffer.wrap(_res);
  }

  /** Entry point to C language function: <code> GLXFBConfig *  glXGetFBConfigs(Display *  dpy, int screen, int *  nelements); </code> <br>Part of CORE FUNC
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  private static native ByteBuffer dispatch_glXGetFBConfigs0(long dpy, int screen, Object nelements, int nelements_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display * , XID, int32_t * , int32_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}
      @param arg3 a direct only {@link java.nio.IntBuffer}   */
  public static boolean glXGetMscRateOML(long arg0, long arg1, IntBuffer arg2, IntBuffer arg3)  {

    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXGetMscRateOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetMscRateOML\" not available");
    }
        return dispatch_glXGetMscRateOML0(arg0, arg1, arg2, Buffers.getDirectBufferByteOffset(arg2), arg3, Buffers.getDirectBufferByteOffset(arg3), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display * , XID, int32_t * , int32_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}
      @param arg3 a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_glXGetMscRateOML0(long arg0, long arg1, Object arg2, int arg2_byte_offset, Object arg3, int arg3_byte_offset, long procAddress);

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddress(const GLubyte *  procname); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public static long glXGetProcAddress(String procname)  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetProcAddress;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetProcAddress\" not available");
    }
        return dispatch_glXGetProcAddress0(procname, __addr_);
  }

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddress(const GLubyte *  procname); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public static native long dispatch_glXGetProcAddress0(String procname, long procAddress);

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddressARB(const GLubyte * ); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public static long glXGetProcAddressARB(String arg0)  {

    final long __addr_ = glxProcAddressTable._addressof_glXGetProcAddressARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetProcAddressARB\" not available");
    }
        return dispatch_glXGetProcAddressARB0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> __GLXextFuncPtr glXGetProcAddressARB(const GLubyte * ); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public static native long dispatch_glXGetProcAddressARB0(String arg0, long procAddress);

  /** Entry point to C language function: <code> void glXGetSelectedEvent(Display *  dpy, XID drawable, unsigned long *  mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param mask a direct only {@link java.nio.LongBuffer}   */
  public static void glXGetSelectedEvent(long dpy, long drawable, LongBuffer mask)  {

    if (!Buffers.isDirect(mask))
      throw new GLException("Argument \"mask\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXGetSelectedEvent;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSelectedEvent\" not available");
    }
        dispatch_glXGetSelectedEvent0(dpy, drawable, mask, Buffers.getDirectBufferByteOffset(mask), __addr_);
  }

  /** Entry point to C language function: <code> void glXGetSelectedEvent(Display *  dpy, XID drawable, unsigned long *  mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param mask a direct only {@link java.nio.LongBuffer}   */
  private static native void dispatch_glXGetSelectedEvent0(long dpy, long drawable, Object mask, int mask_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display * , XID, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg2 a direct only {@link java.nio.LongBuffer}
      @param arg3 a direct only {@link java.nio.LongBuffer}
      @param arg4 a direct only {@link java.nio.LongBuffer}   */
  public static boolean glXGetSyncValuesOML(long arg0, long arg1, LongBuffer arg2, LongBuffer arg3, LongBuffer arg4)  {

    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXGetSyncValuesOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSyncValuesOML\" not available");
    }
        return dispatch_glXGetSyncValuesOML0(arg0, arg1, arg2, Buffers.getDirectBufferByteOffset(arg2), arg3, Buffers.getDirectBufferByteOffset(arg3), arg4, Buffers.getDirectBufferByteOffset(arg4), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display * , XID, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg2 a direct only {@link java.nio.LongBuffer}
      @param arg3 a direct only {@link java.nio.LongBuffer}
      @param arg4 a direct only {@link java.nio.LongBuffer}   */
  private static native boolean dispatch_glXGetSyncValuesOML0(long arg0, long arg1, Object arg2, int arg2_byte_offset, Object arg3, int arg3_byte_offset, Object arg4, int arg4_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXIsDirect(Display *  dpy, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static boolean glXIsDirect(long dpy, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXIsDirect;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXIsDirect\" not available");
    }
        return dispatch_glXIsDirect0(dpy, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXIsDirect(Display *  dpy, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native boolean dispatch_glXIsDirect0(long dpy, long ctx, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeContextCurrent(Display *  dpy, XID draw, XID read, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static boolean glXMakeContextCurrent(long dpy, long draw, long read, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXMakeContextCurrent;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXMakeContextCurrent\" not available");
    }
        return dispatch_glXMakeContextCurrent0(dpy, draw, read, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeContextCurrent(Display *  dpy, XID draw, XID read, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native boolean dispatch_glXMakeContextCurrent0(long dpy, long draw, long read, long ctx, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeCurrent(Display *  dpy, XID drawable, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static boolean glXMakeCurrent(long dpy, long drawable, long ctx)  {

    final long __addr_ = glxProcAddressTable._addressof_glXMakeCurrent;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXMakeCurrent\" not available");
    }
        return dispatch_glXMakeCurrent0(dpy, drawable, ctx, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeCurrent(Display *  dpy, XID drawable, GLXContext ctx); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native boolean dispatch_glXMakeCurrent0(long dpy, long drawable, long ctx, long procAddress);

  /** Entry point to C language function: <code> int glXQueryContext(Display *  dpy, GLXContext ctx, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static int glXQueryContext(long dpy, long ctx, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryContext;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryContext\" not available");
    }
        return dispatch_glXQueryContext0(dpy, ctx, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryContext(Display *  dpy, GLXContext ctx, int attribute, int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native int dispatch_glXQueryContext0(long dpy, long ctx, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXQueryDrawable(Display *  dpy, XID draw, int attribute, unsigned int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  public static void glXQueryDrawable(long dpy, long draw, int attribute, IntBuffer value)  {

    if (!Buffers.isDirect(value))
      throw new GLException("Argument \"value\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryDrawable;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryDrawable\" not available");
    }
        dispatch_glXQueryDrawable0(dpy, draw, attribute, value, Buffers.getDirectBufferByteOffset(value), __addr_);
  }

  /** Entry point to C language function: <code> void glXQueryDrawable(Display *  dpy, XID draw, int attribute, unsigned int *  value); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param value a direct only {@link java.nio.IntBuffer}   */
  private static native void dispatch_glXQueryDrawable0(long dpy, long draw, int attribute, Object value, int value_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryExtension(Display *  dpy, int *  errorb, int *  event); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param errorb a direct only {@link java.nio.IntBuffer}
      @param event a direct only {@link java.nio.IntBuffer}   */
  public static boolean glXQueryExtension(long dpy, IntBuffer errorb, IntBuffer event)  {

    if (!Buffers.isDirect(errorb))
      throw new GLException("Argument \"errorb\" is not a direct buffer");
    if (!Buffers.isDirect(event))
      throw new GLException("Argument \"event\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryExtension;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryExtension\" not available");
    }
        return dispatch_glXQueryExtension0(dpy, errorb, Buffers.getDirectBufferByteOffset(errorb), event, Buffers.getDirectBufferByteOffset(event), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryExtension(Display *  dpy, int *  errorb, int *  event); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param errorb a direct only {@link java.nio.IntBuffer}
      @param event a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_glXQueryExtension0(long dpy, Object errorb, int errorb_byte_offset, Object event, int event_byte_offset, long procAddress);

  /** Entry point to C language function: <code> const char *  glXQueryExtensionsString(Display *  dpy, int screen); </code> <br>Part of CORE FUNC   */
  public static String glXQueryExtensionsString(long dpy, int screen)  {

    final long __addr_ = glxProcAddressTable._addressof_glXQueryExtensionsString;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryExtensionsString\" not available");
    }
        return dispatch_glXQueryExtensionsString0(dpy, screen, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXQueryExtensionsString(Display *  dpy, int screen); </code> <br>Part of CORE FUNC   */
  public static native String dispatch_glXQueryExtensionsString0(long dpy, int screen, long procAddress);

  /** Entry point to C language function: <code> const char *  glXQueryServerString(Display *  dpy, int screen, int name); </code> <br>Part of CORE FUNC   */
  public static String glXQueryServerString(long dpy, int screen, int name)  {

    final long __addr_ = glxProcAddressTable._addressof_glXQueryServerString;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryServerString\" not available");
    }
        return dispatch_glXQueryServerString0(dpy, screen, name, __addr_);
  }

  /** Entry point to C language function: <code> const char *  glXQueryServerString(Display *  dpy, int screen, int name); </code> <br>Part of CORE FUNC   */
  public static native String dispatch_glXQueryServerString0(long dpy, int screen, int name, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryVersion(Display *  dpy, int *  maj, int *  min); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param maj a direct only {@link java.nio.IntBuffer}
      @param min a direct only {@link java.nio.IntBuffer}   */
  public static boolean glXQueryVersion(long dpy, IntBuffer maj, IntBuffer min)  {

    if (!Buffers.isDirect(maj))
      throw new GLException("Argument \"maj\" is not a direct buffer");
    if (!Buffers.isDirect(min))
      throw new GLException("Argument \"min\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXQueryVersion;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryVersion\" not available");
    }
        return dispatch_glXQueryVersion0(dpy, maj, Buffers.getDirectBufferByteOffset(maj), min, Buffers.getDirectBufferByteOffset(min), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryVersion(Display *  dpy, int *  maj, int *  min); </code> <br>Part of <code>GLX_VERSION_1_X</code>
      @param maj a direct only {@link java.nio.IntBuffer}
      @param min a direct only {@link java.nio.IntBuffer}   */
  private static native boolean dispatch_glXQueryVersion0(long dpy, Object maj, int maj_byte_offset, Object min, int min_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public static void glXReleaseTexImageEXT(long dpy, long drawable, int buffer)  {

    final long __addr_ = glxProcAddressTable._addressof_glXReleaseTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseTexImageEXT\" not available");
    }
        dispatch_glXReleaseTexImageEXT0(dpy, drawable, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public static native void dispatch_glXReleaseTexImageEXT0(long dpy, long drawable, int buffer, long procAddress);

  /** Entry point to C language function: <code> void glXSelectEvent(Display *  dpy, XID drawable, unsigned long mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXSelectEvent(long dpy, long drawable, long mask)  {

    final long __addr_ = glxProcAddressTable._addressof_glXSelectEvent;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSelectEvent\" not available");
    }
        dispatch_glXSelectEvent0(dpy, drawable, mask, __addr_);
  }

  /** Entry point to C language function: <code> void glXSelectEvent(Display *  dpy, XID drawable, unsigned long mask); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXSelectEvent0(long dpy, long drawable, long mask, long procAddress);

  /** Entry point to C language function: <code> void glXSwapBuffers(Display *  dpy, XID drawable); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXSwapBuffers(long dpy, long drawable)  {

    final long __addr_ = glxProcAddressTable._addressof_glXSwapBuffers;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSwapBuffers\" not available");
    }
        dispatch_glXSwapBuffers0(dpy, drawable, __addr_);
  }

  /** Entry point to C language function: <code> void glXSwapBuffers(Display *  dpy, XID drawable); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXSwapBuffers0(long dpy, long drawable, long procAddress);

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display * , XID, int64_t, int64_t, int64_t); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public static long glXSwapBuffersMscOML(long arg0, long arg1, long arg2, long arg3, long arg4)  {

    final long __addr_ = glxProcAddressTable._addressof_glXSwapBuffersMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSwapBuffersMscOML\" not available");
    }
        return dispatch_glXSwapBuffersMscOML0(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display * , XID, int64_t, int64_t, int64_t); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public static native long dispatch_glXSwapBuffersMscOML0(long arg0, long arg1, long arg2, long arg3, long arg4, long procAddress);

  /** Entry point to C language function: <code> void glXUseXFont(XID font, int first, int count, int list); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXUseXFont(long font, int first, int count, int list)  {

    final long __addr_ = glxProcAddressTable._addressof_glXUseXFont;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXUseXFont\" not available");
    }
        dispatch_glXUseXFont0(font, first, count, list, __addr_);
  }

  /** Entry point to C language function: <code> void glXUseXFont(XID font, int first, int count, int list); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXUseXFont0(long font, int first, int count, int list, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display * , XID, int64_t, int64_t, int64_t, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg5 a direct only {@link java.nio.LongBuffer}
      @param arg6 a direct only {@link java.nio.LongBuffer}
      @param arg7 a direct only {@link java.nio.LongBuffer}   */
  public static boolean glXWaitForMscOML(long arg0, long arg1, long arg2, long arg3, long arg4, LongBuffer arg5, LongBuffer arg6, LongBuffer arg7)  {

    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    if (!Buffers.isDirect(arg6))
      throw new GLException("Argument \"arg6\" is not a direct buffer");
    if (!Buffers.isDirect(arg7))
      throw new GLException("Argument \"arg7\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXWaitForMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForMscOML\" not available");
    }
        return dispatch_glXWaitForMscOML0(arg0, arg1, arg2, arg3, arg4, arg5, Buffers.getDirectBufferByteOffset(arg5), arg6, Buffers.getDirectBufferByteOffset(arg6), arg7, Buffers.getDirectBufferByteOffset(arg7), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display * , XID, int64_t, int64_t, int64_t, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg5 a direct only {@link java.nio.LongBuffer}
      @param arg6 a direct only {@link java.nio.LongBuffer}
      @param arg7 a direct only {@link java.nio.LongBuffer}   */
  private static native boolean dispatch_glXWaitForMscOML0(long arg0, long arg1, long arg2, long arg3, long arg4, Object arg5, int arg5_byte_offset, Object arg6, int arg6_byte_offset, Object arg7, int arg7_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display * , XID, int64_t, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg3 a direct only {@link java.nio.LongBuffer}
      @param arg4 a direct only {@link java.nio.LongBuffer}
      @param arg5 a direct only {@link java.nio.LongBuffer}   */
  public static boolean glXWaitForSbcOML(long arg0, long arg1, long arg2, LongBuffer arg3, LongBuffer arg4, LongBuffer arg5)  {

    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    final long __addr_ = glxProcAddressTable._addressof_glXWaitForSbcOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForSbcOML\" not available");
    }
        return dispatch_glXWaitForSbcOML0(arg0, arg1, arg2, arg3, Buffers.getDirectBufferByteOffset(arg3), arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display * , XID, int64_t, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg3 a direct only {@link java.nio.LongBuffer}
      @param arg4 a direct only {@link java.nio.LongBuffer}
      @param arg5 a direct only {@link java.nio.LongBuffer}   */
  private static native boolean dispatch_glXWaitForSbcOML0(long arg0, long arg1, long arg2, Object arg3, int arg3_byte_offset, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXWaitGL(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXWaitGL()  {

    final long __addr_ = glxProcAddressTable._addressof_glXWaitGL;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitGL\" not available");
    }
        dispatch_glXWaitGL0(__addr_);
  }

  /** Entry point to C language function: <code> void glXWaitGL(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXWaitGL0(long procAddress);

  /** Entry point to C language function: <code> void glXWaitX(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static void glXWaitX()  {

    final long __addr_ = glxProcAddressTable._addressof_glXWaitX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitX\" not available");
    }
        dispatch_glXWaitX0(__addr_);
  }

  /** Entry point to C language function: <code> void glXWaitX(void); </code> <br>Part of <code>GLX_VERSION_1_X</code>   */
  public static native void dispatch_glXWaitX0(long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
 private static GLXProcAddressTable glxProcAddressTable = new GLXProcAddressTable(new GLProcAddressResolver());
 public  static GLXProcAddressTable getGLXProcAddressTable() { return glxProcAddressTable; }
  
    /** Interface to C language function: <br> - Alias for: <br> <code> XVisualInfo *  glXGetVisualFromFBConfigSGIX, glXGetVisualFromFBConfig(Display *  dpy, GLXFBConfig config); </code>    */
    public static XVisualInfo glXGetVisualFromFBConfig(long dpy, long config)
    {
      final long __addr_ = glxProcAddressTable._addressof_glXGetVisualFromFBConfig;
      if (__addr_ == 0) {
          throw new GLException("Method \"glXGetVisualFromFBConfig\" not available");
      }
      java.nio.ByteBuffer _res;
      _res = dispatch_glXGetVisualFromFBConfig(dpy, config, __addr_);
      if (_res == null) return null;
      return XVisualInfo.create(_res);
    }
  
    /** Entry point to C language function: - Alias for: <br> <code> XVisualInfo *  glXGetVisualFromFBConfigSGIX, glXGetVisualFromFBConfig(Display *  dpy, GLXFBConfig config); </code>    */
    private static native java.nio.ByteBuffer dispatch_glXGetVisualFromFBConfig(long dpy, long config, long procAddr);
  
  
    /** Entry point to C language function: <code> GLXFBConfig *  glXChooseFBConfig(Display *  dpy, int screen, const int *  attribList, int *  nitems); </code> <br>Part of CORE FUNC
        @param attribList a direct only {@link java.nio.IntBuffer}
        @param nitems a direct only {@link java.nio.IntBuffer}   */
    public static PointerBuffer glXChooseFBConfig(long dpy, int screen, IntBuffer attribList, IntBuffer nitems)  {
  
      if (!Buffers.isDirect(attribList))
        throw new GLException("Argument \"attribList\" is not a direct buffer");
      if (!Buffers.isDirect(nitems))
        throw new GLException("Argument \"nitems\" is not a direct buffer");
      final long __addr_ = glxProcAddressTable._addressof_glXChooseFBConfig;
      if (__addr_ == 0) {
        throw new GLException("Method \"glXChooseFBConfig\" not available");
      }
      final ByteBuffer _res;
      _res = dispatch_glXChooseFBConfig(dpy, screen, attribList, Buffers.getDirectBufferByteOffset(attribList), nitems, Buffers.getDirectBufferByteOffset(nitems), __addr_);
      if (_res == null) return null;
      Buffers.nativeOrder(_res);
      return PointerBuffer.wrap(_res);
    }
  
    /** Entry point to C language function: <code> GLXFBConfig *  glXChooseFBConfig(Display *  dpy, int screen, const int *  attribList, int *  nitems); </code> <br>Part of CORE FUNC
        @param attribList a direct only {@link java.nio.IntBuffer}
        @param nitems a direct only {@link java.nio.IntBuffer}   */
    private static native ByteBuffer dispatch_glXChooseFBConfig(long dpy, int screen, Object attribList, int attribList_byte_offset, Object nitems, int nitems_byte_offset, long procAddress);
  
  
    /** Entry point to C language function: <code> XVisualInfo *  glXChooseVisual(Display *  dpy, int screen, int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
        @param attribList a direct only {@link java.nio.IntBuffer}   */
    public static XVisualInfo glXChooseVisual(long dpy, int screen, IntBuffer attribList)  {
  
      if (!Buffers.isDirect(attribList))
        throw new GLException("Argument \"attribList\" is not a direct buffer");
      final long __addr_ = glxProcAddressTable._addressof_glXChooseVisual;
      if (__addr_ == 0) {
        throw new GLException("Method \"glXChooseVisual\" not available");
      }
      final ByteBuffer _res;
      _res = dispatch_glXChooseVisual(dpy, screen, attribList, Buffers.getDirectBufferByteOffset(attribList), __addr_);
      if (_res == null) return null;
      return XVisualInfo.create(Buffers.nativeOrder(_res));
    }
  
    /** Entry point to C language function: <code> XVisualInfo *  glXChooseVisual(Display *  dpy, int screen, int *  attribList); </code> <br>Part of <code>GLX_VERSION_1_X</code>
        @param attribList a direct only {@link java.nio.IntBuffer}   */
    private static native ByteBuffer dispatch_glXChooseVisual(long dpy, int screen, Object attribList, int attribList_byte_offset, long procAddress);
  
  protected static long glXGetProcAddress(long glXGetProcAddressHandle, java.lang.String procname)
  {
    if (glXGetProcAddressHandle == 0) {
      throw new GLException("Passed null pointer for method \"glXGetProcAddress\"");
    }
    return dispatch_glXGetProcAddress0(procname, glXGetProcAddressHandle);
  }
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLX
