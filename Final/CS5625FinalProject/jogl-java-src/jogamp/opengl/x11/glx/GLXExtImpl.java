/* !---- DO NOT EDIT: This file autogenerated by com/jogamp/gluegen/opengl/GLEmitter.java on Thu Nov 01 02:15:46 CET 2012 ----! */

package jogamp.opengl.x11.glx;

import java.util.*;
import javax.media.opengl.*;
import javax.media.opengl.fixedfunc.*;
import jogamp.opengl.*;
import jogamp.nativewindow.x11.*;
import com.jogamp.gluegen.runtime.*;
import com.jogamp.common.os.*;
import com.jogamp.common.nio.*;
import java.nio.*;

public class GLXExtImpl implements GLXExt{
  /** Entry point to C language function: <code> GLvoid *  glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>   */
  public ByteBuffer glXAllocateMemoryNV(int size, float readfreq, float writefreq, float priority)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXAllocateMemoryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXAllocateMemoryNV\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glXAllocateMemoryNV0(size, readfreq, writefreq, priority, __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res;
  }

  /** Entry point to C language function: <code> GLvoid *  glXAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>   */
  private native ByteBuffer dispatch_glXAllocateMemoryNV0(int size, float readfreq, float writefreq, float priority, long procAddress);

  /** Entry point to C language function: <code> int glXBindChannelToWindowSGIX(Display * , int, int, XID); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXBindChannelToWindowSGIX(long arg0, int arg1, int arg2, long arg3)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindChannelToWindowSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindChannelToWindowSGIX\" not available");
    }
        return dispatch_glXBindChannelToWindowSGIX0(arg0, arg1, arg2, arg3, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindChannelToWindowSGIX(Display * , int, int, XID); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public native int dispatch_glXBindChannelToWindowSGIX0(long arg0, int arg1, int arg2, long arg3, long procAddress);

  /** Entry point to C language function: <code> Bool glXBindSwapBarrierNV(Display *  dpy, GLuint group, GLuint barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXBindSwapBarrierNV(long dpy, int group, int barrier)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindSwapBarrierNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindSwapBarrierNV\" not available");
    }
        return dispatch_glXBindSwapBarrierNV0(dpy, group, barrier, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXBindSwapBarrierNV(Display *  dpy, GLuint group, GLuint barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public native boolean dispatch_glXBindSwapBarrierNV0(long dpy, int group, int barrier, long procAddress);

  /** Entry point to C language function: <code> void glXBindSwapBarrierSGIX(Display * , XID, int); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>   */
  public void glXBindSwapBarrierSGIX(long arg0, long arg1, int arg2)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindSwapBarrierSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindSwapBarrierSGIX\" not available");
    }
        dispatch_glXBindSwapBarrierSGIX0(arg0, arg1, arg2, __addr_);
  }

  /** Entry point to C language function: <code> void glXBindSwapBarrierSGIX(Display * , XID, int); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>   */
  public native void dispatch_glXBindSwapBarrierSGIX0(long arg0, long arg1, int arg2, long procAddress);

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public void glXBindTexImageEXT(long dpy, long drawable, int buffer, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindTexImageEXT\" not available");
    }
        dispatch_glXBindTexImageEXT0(dpy, drawable, buffer, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> void glXBindTexImageEXT(Display *  dpy, XID drawable, int buffer, const int *  attrib_list); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native void dispatch_glXBindTexImageEXT0(long dpy, long drawable, int buffer, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXBindVideoDeviceNV(Display *  dpy, unsigned int video_slot, unsigned int video_device, const int *  attrib_list); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  public int glXBindVideoDeviceNV(long dpy, int video_slot, int video_device, IntBuffer attrib_list)  {

    if (!Buffers.isDirect(attrib_list))
      throw new GLException("Argument \"attrib_list\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindVideoDeviceNV\" not available");
    }
        return dispatch_glXBindVideoDeviceNV0(dpy, video_slot, video_device, attrib_list, Buffers.getDirectBufferByteOffset(attrib_list), __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoDeviceNV(Display *  dpy, unsigned int video_slot, unsigned int video_device, const int *  attrib_list); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param attrib_list a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXBindVideoDeviceNV0(long dpy, int video_slot, int video_device, Object attrib_list, int attrib_list_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXBindVideoImageNV(Display *  dpy, GLXVideoDeviceNV VideoDevice, XID pbuf, int iVideoBuffer); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public int glXBindVideoImageNV(long dpy, int VideoDevice, long pbuf, int iVideoBuffer)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXBindVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXBindVideoImageNV\" not available");
    }
        return dispatch_glXBindVideoImageNV0(dpy, VideoDevice, pbuf, iVideoBuffer, __addr_);
  }

  /** Entry point to C language function: <code> int glXBindVideoImageNV(Display *  dpy, GLXVideoDeviceNV VideoDevice, XID pbuf, int iVideoBuffer); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public native int dispatch_glXBindVideoImageNV0(long dpy, int VideoDevice, long pbuf, int iVideoBuffer, long procAddress);

  /** Entry point to C language function: <code> int glXChannelRectSGIX(Display * , int, int, int, int, int, int); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXChannelRectSGIX(long arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXChannelRectSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXChannelRectSGIX\" not available");
    }
        return dispatch_glXChannelRectSGIX0(arg0, arg1, arg2, arg3, arg4, arg5, arg6, __addr_);
  }

  /** Entry point to C language function: <code> int glXChannelRectSGIX(Display * , int, int, int, int, int, int); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public native int dispatch_glXChannelRectSGIX0(long arg0, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, long procAddress);

  /** Entry point to C language function: <code> int glXChannelRectSyncSGIX(Display * , int, int, GLenum); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public int glXChannelRectSyncSGIX(long arg0, int arg1, int arg2, int arg3)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXChannelRectSyncSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXChannelRectSyncSGIX\" not available");
    }
        return dispatch_glXChannelRectSyncSGIX0(arg0, arg1, arg2, arg3, __addr_);
  }

  /** Entry point to C language function: <code> int glXChannelRectSyncSGIX(Display * , int, int, GLenum); </code> <br>Part of <code>GLX_SGIX_video_resize</code>   */
  public native int dispatch_glXChannelRectSyncSGIX0(long arg0, int arg1, int arg2, int arg3, long procAddress);

  /** Entry point to C language function: <code> void glXCopySubBufferMESA(Display * , XID, int, int, int, int); </code> <br>Part of <code>GLX_MESA_copy_sub_buffer</code>   */
  public void glXCopySubBufferMESA(long arg0, long arg1, int arg2, int arg3, int arg4, int arg5)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCopySubBufferMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCopySubBufferMESA\" not available");
    }
        dispatch_glXCopySubBufferMESA0(arg0, arg1, arg2, arg3, arg4, arg5, __addr_);
  }

  /** Entry point to C language function: <code> void glXCopySubBufferMESA(Display * , XID, int, int, int, int); </code> <br>Part of <code>GLX_MESA_copy_sub_buffer</code>   */
  public native void dispatch_glXCopySubBufferMESA0(long arg0, long arg1, int arg2, int arg3, int arg4, int arg5, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXCreateContextAttribsARB(Display * , GLXFBConfig, GLXContext, Bool, const int * ); </code> <br>Part of <code>GLX_ARB_create_context</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}   */
  public long glXCreateContextAttribsARB(long arg0, long arg1, long arg2, boolean arg3, IntBuffer arg4)  {

    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCreateContextAttribsARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCreateContextAttribsARB\" not available");
    }
        return dispatch_glXCreateContextAttribsARB0(arg0, arg1, arg2, arg3, arg4, Buffers.getDirectBufferByteOffset(arg4), __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXCreateContextAttribsARB(Display * , GLXFBConfig, GLXContext, Bool, const int * ); </code> <br>Part of <code>GLX_ARB_create_context</code>
      @param arg4 a direct only {@link java.nio.IntBuffer}   */
  private native long dispatch_glXCreateContextAttribsARB0(long arg0, long arg1, long arg2, boolean arg3, Object arg4, int arg4_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXCushionSGI(Display * , XID, float); </code> <br>Part of <code>GLX_SGI_cushion</code>   */
  public void glXCushionSGI(long arg0, long arg1, float arg2)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXCushionSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXCushionSGI\" not available");
    }
        dispatch_glXCushionSGI0(arg0, arg1, arg2, __addr_);
  }

  /** Entry point to C language function: <code> void glXCushionSGI(Display * , XID, float); </code> <br>Part of <code>GLX_SGI_cushion</code>   */
  public native void dispatch_glXCushionSGI0(long arg0, long arg1, float arg2, long procAddress);

  /** Entry point to C language function: <code> unsigned int *  glXEnumerateVideoDevicesNV(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  public IntBuffer glXEnumerateVideoDevicesNV(long dpy, int screen, IntBuffer nelements)  {

    if (!Buffers.isDirect(nelements))
      throw new GLException("Argument \"nelements\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXEnumerateVideoDevicesNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXEnumerateVideoDevicesNV\" not available");
    }
    final ByteBuffer _res;
    _res = dispatch_glXEnumerateVideoDevicesNV0(dpy, screen, nelements, Buffers.getDirectBufferByteOffset(nelements), __addr_);
    if (_res == null) return null;
    Buffers.nativeOrder(_res);
    return _res.asIntBuffer();
  }

  /** Entry point to C language function: <code> unsigned int *  glXEnumerateVideoDevicesNV(Display *  dpy, int screen, int *  nelements); </code> <br>Part of <code>GLX_NV_present_video</code>
      @param nelements a direct only {@link java.nio.IntBuffer}   */
  private native ByteBuffer dispatch_glXEnumerateVideoDevicesNV0(long dpy, int screen, Object nelements, int nelements_byte_offset, long procAddress);

  /** Entry point to C language function: <code> void glXFreeContextEXT(Display * , GLXContext); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public void glXFreeContextEXT(long arg0, long arg1)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXFreeContextEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXFreeContextEXT\" not available");
    }
        dispatch_glXFreeContextEXT0(arg0, arg1, __addr_);
  }

  /** Entry point to C language function: <code> void glXFreeContextEXT(Display * , GLXContext); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public native void dispatch_glXFreeContextEXT0(long arg0, long arg1, long procAddress);

  /** Entry point to C language function: <code> void glXFreeMemoryNV(GLvoid *  pointer); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  public void glXFreeMemoryNV(Buffer pointer)  {

    if (!Buffers.isDirect(pointer))
      throw new GLException("Argument \"pointer\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXFreeMemoryNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXFreeMemoryNV\" not available");
    }
        dispatch_glXFreeMemoryNV0(pointer, Buffers.getDirectBufferByteOffset(pointer), __addr_);
  }

  /** Entry point to C language function: <code> void glXFreeMemoryNV(GLvoid *  pointer); </code> <br>Part of <code>GLX_NV_vertex_array_range</code>
      @param pointer a direct only {@link java.nio.Buffer}   */
  private native void dispatch_glXFreeMemoryNV0(Object pointer, int pointer_byte_offset, long procAddress);

  /** Entry point to C language function: <code> unsigned int glXGetAGPOffsetMESA(const void * ); </code> <br>Part of <code>GLX_MESA_agp_offset</code>
      @param arg0 a direct only {@link java.nio.Buffer}   */
  public int glXGetAGPOffsetMESA(Buffer arg0)  {

    if (!Buffers.isDirect(arg0))
      throw new GLException("Argument \"arg0\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetAGPOffsetMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetAGPOffsetMESA\" not available");
    }
        return dispatch_glXGetAGPOffsetMESA0(arg0, Buffers.getDirectBufferByteOffset(arg0), __addr_);
  }

  /** Entry point to C language function: <code> unsigned int glXGetAGPOffsetMESA(const void * ); </code> <br>Part of <code>GLX_MESA_agp_offset</code>
      @param arg0 a direct only {@link java.nio.Buffer}   */
  private native int dispatch_glXGetAGPOffsetMESA0(Object arg0, int arg0_byte_offset, long procAddress);

  /** Entry point to C language function: <code> XID glXGetContextIDEXT(GLXContext); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public long glXGetContextIDEXT(long arg0)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetContextIDEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetContextIDEXT\" not available");
    }
        return dispatch_glXGetContextIDEXT0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> XID glXGetContextIDEXT(GLXContext); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public native long dispatch_glXGetContextIDEXT0(long arg0, long procAddress);

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplayEXT(void); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public long glXGetCurrentDisplayEXT()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetCurrentDisplayEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentDisplayEXT\" not available");
    }
        return dispatch_glXGetCurrentDisplayEXT0(__addr_);
  }

  /** Entry point to C language function: <code> Display *  glXGetCurrentDisplayEXT(void); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public native long dispatch_glXGetCurrentDisplayEXT0(long procAddress);

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawableSGI(void); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public long glXGetCurrentReadDrawableSGI()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetCurrentReadDrawableSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetCurrentReadDrawableSGI\" not available");
    }
        return dispatch_glXGetCurrentReadDrawableSGI0(__addr_);
  }

  /** Entry point to C language function: <code> XID glXGetCurrentReadDrawableSGI(void); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public native long dispatch_glXGetCurrentReadDrawableSGI0(long procAddress);

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display * , XID, int32_t * , int32_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}
      @param arg3 a direct only {@link java.nio.IntBuffer}   */
  public boolean glXGetMscRateOML(long arg0, long arg1, IntBuffer arg2, IntBuffer arg3)  {

    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetMscRateOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetMscRateOML\" not available");
    }
        return dispatch_glXGetMscRateOML0(arg0, arg1, arg2, Buffers.getDirectBufferByteOffset(arg2), arg3, Buffers.getDirectBufferByteOffset(arg3), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetMscRateOML(Display * , XID, int32_t * , int32_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}
      @param arg3 a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXGetMscRateOML0(long arg0, long arg1, Object arg2, int arg2_byte_offset, Object arg3, int arg3_byte_offset, long procAddress);

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddress(const GLubyte * ); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public long glXGetProcAddress(String arg0)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetProcAddress;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetProcAddress\" not available");
    }
        return dispatch_glXGetProcAddress0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddress(const GLubyte * ); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public native long dispatch_glXGetProcAddress0(String arg0, long procAddress);

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddressARB(const GLubyte * ); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public long glXGetProcAddressARB(String arg0)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetProcAddressARB;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetProcAddressARB\" not available");
    }
        return dispatch_glXGetProcAddressARB0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> PFNGLENDTRANSFORMFEEDBACKPROC glXGetProcAddressARB(const GLubyte * ); </code> <br>Part of <code>GLX_ARB_get_proc_address</code>   */
  public native long dispatch_glXGetProcAddressARB0(String arg0, long procAddress);

  /** Entry point to C language function: <code> int glXGetRefreshRateSGI(unsigned int * ); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param arg0 a direct only {@link java.nio.IntBuffer}   */
  public int glXGetRefreshRateSGI(IntBuffer arg0)  {

    if (!Buffers.isDirect(arg0))
      throw new GLException("Argument \"arg0\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetRefreshRateSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetRefreshRateSGI\" not available");
    }
        return dispatch_glXGetRefreshRateSGI0(arg0, Buffers.getDirectBufferByteOffset(arg0), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetRefreshRateSGI(unsigned int * ); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param arg0 a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetRefreshRateSGI0(Object arg0, int arg0_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXGetSwapIntervalMESA(void); </code> <br>Part of <code>GLX_MESA_swap_control</code>   */
  public int glXGetSwapIntervalMESA()  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetSwapIntervalMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSwapIntervalMESA\" not available");
    }
        return dispatch_glXGetSwapIntervalMESA0(__addr_);
  }

  /** Entry point to C language function: <code> int glXGetSwapIntervalMESA(void); </code> <br>Part of <code>GLX_MESA_swap_control</code>   */
  public native int dispatch_glXGetSwapIntervalMESA0(long procAddress);

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display * , XID, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg2 a direct only {@link java.nio.LongBuffer}
      @param arg3 a direct only {@link java.nio.LongBuffer}
      @param arg4 a direct only {@link java.nio.LongBuffer}   */
  public boolean glXGetSyncValuesOML(long arg0, long arg1, LongBuffer arg2, LongBuffer arg3, LongBuffer arg4)  {

    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetSyncValuesOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetSyncValuesOML\" not available");
    }
        return dispatch_glXGetSyncValuesOML0(arg0, arg1, arg2, Buffers.getDirectBufferByteOffset(arg2), arg3, Buffers.getDirectBufferByteOffset(arg3), arg4, Buffers.getDirectBufferByteOffset(arg4), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXGetSyncValuesOML(Display * , XID, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg2 a direct only {@link java.nio.LongBuffer}
      @param arg3 a direct only {@link java.nio.LongBuffer}
      @param arg4 a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXGetSyncValuesOML0(long arg0, long arg1, Object arg2, int arg2_byte_offset, Object arg3, int arg3_byte_offset, Object arg4, int arg4_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Status glXGetTransparentIndexSUN(Display * , XID, XID, long * ); </code> <br>Part of <code>GLX_SUN_get_transparent_index</code>
      @param arg3 a direct only {@link java.nio.LongBuffer}   */
  public int glXGetTransparentIndexSUN(long arg0, long arg1, long arg2, LongBuffer arg3)  {

    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetTransparentIndexSUN;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetTransparentIndexSUN\" not available");
    }
        return dispatch_glXGetTransparentIndexSUN0(arg0, arg1, arg2, arg3, Buffers.getDirectBufferByteOffset(arg3), __addr_);
  }

  /** Entry point to C language function: <code> Status glXGetTransparentIndexSUN(Display * , XID, XID, long * ); </code> <br>Part of <code>GLX_SUN_get_transparent_index</code>
      @param arg3 a direct only {@link java.nio.LongBuffer}   */
  private native int dispatch_glXGetTransparentIndexSUN0(long arg0, long arg1, long arg2, Object arg3, int arg3_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoDeviceNV(Display *  dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *  pVideoDevice); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pVideoDevice a direct only {@link java.nio.IntBuffer}   */
  public int glXGetVideoDeviceNV(long dpy, int screen, int numVideoDevices, IntBuffer pVideoDevice)  {

    if (!Buffers.isDirect(pVideoDevice))
      throw new GLException("Argument \"pVideoDevice\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetVideoDeviceNV\" not available");
    }
        return dispatch_glXGetVideoDeviceNV0(dpy, screen, numVideoDevices, pVideoDevice, Buffers.getDirectBufferByteOffset(pVideoDevice), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoDeviceNV(Display *  dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *  pVideoDevice); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pVideoDevice a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetVideoDeviceNV0(long dpy, int screen, int numVideoDevices, Object pVideoDevice, int pVideoDevice_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoInfoNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pulCounterOutputPbuffer a direct only {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct only {@link java.nio.LongBuffer}   */
  public int glXGetVideoInfoNV(long dpy, int screen, int VideoDevice, LongBuffer pulCounterOutputPbuffer, LongBuffer pulCounterOutputVideo)  {

    if (!Buffers.isDirect(pulCounterOutputPbuffer))
      throw new GLException("Argument \"pulCounterOutputPbuffer\" is not a direct buffer");
    if (!Buffers.isDirect(pulCounterOutputVideo))
      throw new GLException("Argument \"pulCounterOutputVideo\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoInfoNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetVideoInfoNV\" not available");
    }
        return dispatch_glXGetVideoInfoNV0(dpy, screen, VideoDevice, pulCounterOutputPbuffer, Buffers.getDirectBufferByteOffset(pulCounterOutputPbuffer), pulCounterOutputVideo, Buffers.getDirectBufferByteOffset(pulCounterOutputVideo), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoInfoNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *  pulCounterOutputPbuffer, unsigned long *  pulCounterOutputVideo); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pulCounterOutputPbuffer a direct only {@link java.nio.LongBuffer}
      @param pulCounterOutputVideo a direct only {@link java.nio.LongBuffer}   */
  private native int dispatch_glXGetVideoInfoNV0(long dpy, int screen, int VideoDevice, Object pulCounterOutputPbuffer, int pulCounterOutputPbuffer_byte_offset, Object pulCounterOutputVideo, int pulCounterOutputVideo_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXGetVideoSyncSGI(unsigned int * ); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param arg0 a direct only {@link java.nio.IntBuffer}   */
  public int glXGetVideoSyncSGI(IntBuffer arg0)  {

    if (!Buffers.isDirect(arg0))
      throw new GLException("Argument \"arg0\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXGetVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXGetVideoSyncSGI\" not available");
    }
        return dispatch_glXGetVideoSyncSGI0(arg0, Buffers.getDirectBufferByteOffset(arg0), __addr_);
  }

  /** Entry point to C language function: <code> int glXGetVideoSyncSGI(unsigned int * ); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param arg0 a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXGetVideoSyncSGI0(Object arg0, int arg0_byte_offset, long procAddress);

  /** Entry point to C language function: <code> GLXContext glXImportContextEXT(Display * , XID); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public long glXImportContextEXT(long arg0, long arg1)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXImportContextEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXImportContextEXT\" not available");
    }
        return dispatch_glXImportContextEXT0(arg0, arg1, __addr_);
  }

  /** Entry point to C language function: <code> GLXContext glXImportContextEXT(Display * , XID); </code> <br>Part of <code>GLX_EXT_import_context</code>   */
  public native long dispatch_glXImportContextEXT0(long arg0, long arg1, long procAddress);

  /** Entry point to C language function: <code> Bool glXJoinSwapGroupNV(Display *  dpy, XID drawable, GLuint group); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXJoinSwapGroupNV(long dpy, long drawable, int group)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXJoinSwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXJoinSwapGroupNV\" not available");
    }
        return dispatch_glXJoinSwapGroupNV0(dpy, drawable, group, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXJoinSwapGroupNV(Display *  dpy, XID drawable, GLuint group); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public native boolean dispatch_glXJoinSwapGroupNV0(long dpy, long drawable, int group, long procAddress);

  /** Entry point to C language function: <code> void glXJoinSwapGroupSGIX(Display * , XID, XID); </code> <br>Part of <code>GLX_SGIX_swap_group</code>   */
  public void glXJoinSwapGroupSGIX(long arg0, long arg1, long arg2)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXJoinSwapGroupSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXJoinSwapGroupSGIX\" not available");
    }
        dispatch_glXJoinSwapGroupSGIX0(arg0, arg1, arg2, __addr_);
  }

  /** Entry point to C language function: <code> void glXJoinSwapGroupSGIX(Display * , XID, XID); </code> <br>Part of <code>GLX_SGIX_swap_group</code>   */
  public native void dispatch_glXJoinSwapGroupSGIX0(long arg0, long arg1, long arg2, long procAddress);

  /** Entry point to C language function: <code> Bool glXMakeCurrentReadSGI(Display * , XID, XID, GLXContext); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public boolean glXMakeCurrentReadSGI(long arg0, long arg1, long arg2, long arg3)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXMakeCurrentReadSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXMakeCurrentReadSGI\" not available");
    }
        return dispatch_glXMakeCurrentReadSGI0(arg0, arg1, arg2, arg3, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXMakeCurrentReadSGI(Display * , XID, XID, GLXContext); </code> <br>Part of <code>GLX_SGI_make_current_read</code>   */
  public native boolean dispatch_glXMakeCurrentReadSGI0(long arg0, long arg1, long arg2, long arg3, long procAddress);

  /** Entry point to C language function: <code> int glXQueryChannelDeltasSGIX(Display * , int, int, int * , int * , int * , int * ); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param arg3 a direct only {@link java.nio.IntBuffer}
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}
      @param arg6 a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryChannelDeltasSGIX(long arg0, int arg1, int arg2, IntBuffer arg3, IntBuffer arg4, IntBuffer arg5, IntBuffer arg6)  {

    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    if (!Buffers.isDirect(arg6))
      throw new GLException("Argument \"arg6\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelDeltasSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryChannelDeltasSGIX\" not available");
    }
        return dispatch_glXQueryChannelDeltasSGIX0(arg0, arg1, arg2, arg3, Buffers.getDirectBufferByteOffset(arg3), arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), arg6, Buffers.getDirectBufferByteOffset(arg6), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryChannelDeltasSGIX(Display * , int, int, int * , int * , int * , int * ); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param arg3 a direct only {@link java.nio.IntBuffer}
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}
      @param arg6 a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryChannelDeltasSGIX0(long arg0, int arg1, int arg2, Object arg3, int arg3_byte_offset, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, Object arg6, int arg6_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXQueryChannelRectSGIX(Display * , int, int, int * , int * , int * , int * ); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param arg3 a direct only {@link java.nio.IntBuffer}
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}
      @param arg6 a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryChannelRectSGIX(long arg0, int arg1, int arg2, IntBuffer arg3, IntBuffer arg4, IntBuffer arg5, IntBuffer arg6)  {

    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    if (!Buffers.isDirect(arg6))
      throw new GLException("Argument \"arg6\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryChannelRectSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryChannelRectSGIX\" not available");
    }
        return dispatch_glXQueryChannelRectSGIX0(arg0, arg1, arg2, arg3, Buffers.getDirectBufferByteOffset(arg3), arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), arg6, Buffers.getDirectBufferByteOffset(arg6), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryChannelRectSGIX(Display * , int, int, int * , int * , int * , int * ); </code> <br>Part of <code>GLX_SGIX_video_resize</code>
      @param arg3 a direct only {@link java.nio.IntBuffer}
      @param arg4 a direct only {@link java.nio.IntBuffer}
      @param arg5 a direct only {@link java.nio.IntBuffer}
      @param arg6 a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryChannelRectSGIX0(long arg0, int arg1, int arg2, Object arg3, int arg3_byte_offset, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, Object arg6, int arg6_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXQueryContextInfoEXT(Display * , GLXContext, int, int * ); </code> <br>Part of <code>GLX_EXT_import_context</code>
      @param arg3 a direct only {@link java.nio.IntBuffer}   */
  public int glXQueryContextInfoEXT(long arg0, long arg1, int arg2, IntBuffer arg3)  {

    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryContextInfoEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryContextInfoEXT\" not available");
    }
        return dispatch_glXQueryContextInfoEXT0(arg0, arg1, arg2, arg3, Buffers.getDirectBufferByteOffset(arg3), __addr_);
  }

  /** Entry point to C language function: <code> int glXQueryContextInfoEXT(Display * , GLXContext, int, int * ); </code> <br>Part of <code>GLX_EXT_import_context</code>
      @param arg3 a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXQueryContextInfoEXT0(long arg0, long arg1, int arg2, Object arg3, int arg3_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryFrameCountNV(Display *  dpy, int screen, GLuint *  count); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryFrameCountNV(long dpy, int screen, IntBuffer count)  {

    if (!Buffers.isDirect(count))
      throw new GLException("Argument \"count\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryFrameCountNV\" not available");
    }
        return dispatch_glXQueryFrameCountNV0(dpy, screen, count, Buffers.getDirectBufferByteOffset(count), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryFrameCountNV(Display *  dpy, int screen, GLuint *  count); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param count a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryFrameCountNV0(long dpy, int screen, Object count, int count_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapBarriersSGIX(Display * , int, int * ); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryMaxSwapBarriersSGIX(long arg0, int arg1, IntBuffer arg2)  {

    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapBarriersSGIX;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryMaxSwapBarriersSGIX\" not available");
    }
        return dispatch_glXQueryMaxSwapBarriersSGIX0(arg0, arg1, arg2, Buffers.getDirectBufferByteOffset(arg2), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapBarriersSGIX(Display * , int, int * ); </code> <br>Part of <code>GLX_SGIX_swap_barrier</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryMaxSwapBarriersSGIX0(long arg0, int arg1, Object arg2, int arg2_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapGroupsNV(Display *  dpy, int screen, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQueryMaxSwapGroupsNV(long dpy, int screen, IntBuffer maxGroups, IntBuffer maxBarriers)  {

    if (!Buffers.isDirect(maxGroups))
      throw new GLException("Argument \"maxGroups\" is not a direct buffer");
    if (!Buffers.isDirect(maxBarriers))
      throw new GLException("Argument \"maxBarriers\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQueryMaxSwapGroupsNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQueryMaxSwapGroupsNV\" not available");
    }
        return dispatch_glXQueryMaxSwapGroupsNV0(dpy, screen, maxGroups, Buffers.getDirectBufferByteOffset(maxGroups), maxBarriers, Buffers.getDirectBufferByteOffset(maxBarriers), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQueryMaxSwapGroupsNV(Display *  dpy, int screen, GLuint *  maxGroups, GLuint *  maxBarriers); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param maxGroups a direct only {@link java.nio.IntBuffer}
      @param maxBarriers a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQueryMaxSwapGroupsNV0(long dpy, int screen, Object maxGroups, int maxGroups_byte_offset, Object maxBarriers, int maxBarriers_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXQuerySwapGroupNV(Display *  dpy, XID drawable, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  public boolean glXQuerySwapGroupNV(long dpy, long drawable, IntBuffer group, IntBuffer barrier)  {

    if (!Buffers.isDirect(group))
      throw new GLException("Argument \"group\" is not a direct buffer");
    if (!Buffers.isDirect(barrier))
      throw new GLException("Argument \"barrier\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXQuerySwapGroupNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXQuerySwapGroupNV\" not available");
    }
        return dispatch_glXQuerySwapGroupNV0(dpy, drawable, group, Buffers.getDirectBufferByteOffset(group), barrier, Buffers.getDirectBufferByteOffset(barrier), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXQuerySwapGroupNV(Display *  dpy, XID drawable, GLuint *  group, GLuint *  barrier); </code> <br>Part of <code>GLX_NV_swap_group</code>
      @param group a direct only {@link java.nio.IntBuffer}
      @param barrier a direct only {@link java.nio.IntBuffer}   */
  private native boolean dispatch_glXQuerySwapGroupNV0(long dpy, long drawable, Object group, int group_byte_offset, Object barrier, int barrier_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXReleaseBuffersMESA(Display * , XID); </code> <br>Part of <code>GLX_MESA_release_buffers</code>   */
  public boolean glXReleaseBuffersMESA(long arg0, long arg1)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseBuffersMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseBuffersMESA\" not available");
    }
        return dispatch_glXReleaseBuffersMESA0(arg0, arg1, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXReleaseBuffersMESA(Display * , XID); </code> <br>Part of <code>GLX_MESA_release_buffers</code>   */
  public native boolean dispatch_glXReleaseBuffersMESA0(long arg0, long arg1, long procAddress);

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public void glXReleaseTexImageEXT(long dpy, long drawable, int buffer)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseTexImageEXT;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseTexImageEXT\" not available");
    }
        dispatch_glXReleaseTexImageEXT0(dpy, drawable, buffer, __addr_);
  }

  /** Entry point to C language function: <code> void glXReleaseTexImageEXT(Display *  dpy, XID drawable, int buffer); </code> <br>Part of <code>GLX_EXT_texture_from_pixmap</code>   */
  public native void dispatch_glXReleaseTexImageEXT0(long dpy, long drawable, int buffer, long procAddress);

  /** Entry point to C language function: <code> int glXReleaseVideoDeviceNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public int glXReleaseVideoDeviceNV(long dpy, int screen, int VideoDevice)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoDeviceNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseVideoDeviceNV\" not available");
    }
        return dispatch_glXReleaseVideoDeviceNV0(dpy, screen, VideoDevice, __addr_);
  }

  /** Entry point to C language function: <code> int glXReleaseVideoDeviceNV(Display *  dpy, int screen, GLXVideoDeviceNV VideoDevice); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public native int dispatch_glXReleaseVideoDeviceNV0(long dpy, int screen, int VideoDevice, long procAddress);

  /** Entry point to C language function: <code> int glXReleaseVideoImageNV(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public int glXReleaseVideoImageNV(long dpy, long pbuf)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXReleaseVideoImageNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXReleaseVideoImageNV\" not available");
    }
        return dispatch_glXReleaseVideoImageNV0(dpy, pbuf, __addr_);
  }

  /** Entry point to C language function: <code> int glXReleaseVideoImageNV(Display *  dpy, XID pbuf); </code> <br>Part of <code>GLX_NV_video_out</code>   */
  public native int dispatch_glXReleaseVideoImageNV0(long dpy, long pbuf, long procAddress);

  /** Entry point to C language function: <code> Bool glXResetFrameCountNV(Display *  dpy, int screen); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public boolean glXResetFrameCountNV(long dpy, int screen)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXResetFrameCountNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXResetFrameCountNV\" not available");
    }
        return dispatch_glXResetFrameCountNV0(dpy, screen, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXResetFrameCountNV(Display *  dpy, int screen); </code> <br>Part of <code>GLX_NV_swap_group</code>   */
  public native boolean dispatch_glXResetFrameCountNV0(long dpy, int screen, long procAddress);

  /** Entry point to C language function: <code> int glXSendPbufferToVideoNV(Display *  dpy, XID pbuf, int iBufferType, unsigned long *  pulCounterPbuffer, GLboolean bBlock); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pulCounterPbuffer a direct only {@link java.nio.LongBuffer}   */
  public int glXSendPbufferToVideoNV(long dpy, long pbuf, int iBufferType, LongBuffer pulCounterPbuffer, boolean bBlock)  {

    if (!Buffers.isDirect(pulCounterPbuffer))
      throw new GLException("Argument \"pulCounterPbuffer\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSendPbufferToVideoNV;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSendPbufferToVideoNV\" not available");
    }
        return dispatch_glXSendPbufferToVideoNV0(dpy, pbuf, iBufferType, pulCounterPbuffer, Buffers.getDirectBufferByteOffset(pulCounterPbuffer), bBlock, __addr_);
  }

  /** Entry point to C language function: <code> int glXSendPbufferToVideoNV(Display *  dpy, XID pbuf, int iBufferType, unsigned long *  pulCounterPbuffer, GLboolean bBlock); </code> <br>Part of <code>GLX_NV_video_out</code>
      @param pulCounterPbuffer a direct only {@link java.nio.LongBuffer}   */
  private native int dispatch_glXSendPbufferToVideoNV0(long dpy, long pbuf, int iBufferType, Object pulCounterPbuffer, int pulCounterPbuffer_byte_offset, boolean bBlock, long procAddress);

  /** Entry point to C language function: <code> Bool glXSet3DfxModeMESA(int); </code> <br>Part of <code>GLX_MESA_set_3dfx_mode</code>   */
  public boolean glXSet3DfxModeMESA(int arg0)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSet3DfxModeMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSet3DfxModeMESA\" not available");
    }
        return dispatch_glXSet3DfxModeMESA0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> Bool glXSet3DfxModeMESA(int); </code> <br>Part of <code>GLX_MESA_set_3dfx_mode</code>   */
  public native boolean dispatch_glXSet3DfxModeMESA0(int arg0, long procAddress);

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display * , XID, int64_t, int64_t, int64_t); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public long glXSwapBuffersMscOML(long arg0, long arg1, long arg2, long arg3, long arg4)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapBuffersMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSwapBuffersMscOML\" not available");
    }
        return dispatch_glXSwapBuffersMscOML0(arg0, arg1, arg2, arg3, arg4, __addr_);
  }

  /** Entry point to C language function: <code> int64_t glXSwapBuffersMscOML(Display * , XID, int64_t, int64_t, int64_t); </code> <br>Part of <code>GLX_OML_sync_control</code>   */
  public native long dispatch_glXSwapBuffersMscOML0(long arg0, long arg1, long arg2, long arg3, long arg4, long procAddress);

  /** Entry point to C language function: <code> int glXSwapIntervalMESA(unsigned int interval); </code> <br>Part of <code>GLX_MESA_swap_control</code>   */
  public int glXSwapIntervalMESA(int interval)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapIntervalMESA;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSwapIntervalMESA\" not available");
    }
        return dispatch_glXSwapIntervalMESA0(interval, __addr_);
  }

  /** Entry point to C language function: <code> int glXSwapIntervalMESA(unsigned int interval); </code> <br>Part of <code>GLX_MESA_swap_control</code>   */
  public native int dispatch_glXSwapIntervalMESA0(int interval, long procAddress);

  /** Entry point to C language function: <code> int glXSwapIntervalSGI(int); </code> <br>Part of <code>GLX_SGI_swap_control</code>   */
  public int glXSwapIntervalSGI(int arg0)  {

    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXSwapIntervalSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXSwapIntervalSGI\" not available");
    }
        return dispatch_glXSwapIntervalSGI0(arg0, __addr_);
  }

  /** Entry point to C language function: <code> int glXSwapIntervalSGI(int); </code> <br>Part of <code>GLX_SGI_swap_control</code>   */
  public native int dispatch_glXSwapIntervalSGI0(int arg0, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display * , XID, int64_t, int64_t, int64_t, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg5 a direct only {@link java.nio.LongBuffer}
      @param arg6 a direct only {@link java.nio.LongBuffer}
      @param arg7 a direct only {@link java.nio.LongBuffer}   */
  public boolean glXWaitForMscOML(long arg0, long arg1, long arg2, long arg3, long arg4, LongBuffer arg5, LongBuffer arg6, LongBuffer arg7)  {

    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    if (!Buffers.isDirect(arg6))
      throw new GLException("Argument \"arg6\" is not a direct buffer");
    if (!Buffers.isDirect(arg7))
      throw new GLException("Argument \"arg7\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForMscOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForMscOML\" not available");
    }
        return dispatch_glXWaitForMscOML0(arg0, arg1, arg2, arg3, arg4, arg5, Buffers.getDirectBufferByteOffset(arg5), arg6, Buffers.getDirectBufferByteOffset(arg6), arg7, Buffers.getDirectBufferByteOffset(arg7), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForMscOML(Display * , XID, int64_t, int64_t, int64_t, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg5 a direct only {@link java.nio.LongBuffer}
      @param arg6 a direct only {@link java.nio.LongBuffer}
      @param arg7 a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXWaitForMscOML0(long arg0, long arg1, long arg2, long arg3, long arg4, Object arg5, int arg5_byte_offset, Object arg6, int arg6_byte_offset, Object arg7, int arg7_byte_offset, long procAddress);

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display * , XID, int64_t, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg3 a direct only {@link java.nio.LongBuffer}
      @param arg4 a direct only {@link java.nio.LongBuffer}
      @param arg5 a direct only {@link java.nio.LongBuffer}   */
  public boolean glXWaitForSbcOML(long arg0, long arg1, long arg2, LongBuffer arg3, LongBuffer arg4, LongBuffer arg5)  {

    if (!Buffers.isDirect(arg3))
      throw new GLException("Argument \"arg3\" is not a direct buffer");
    if (!Buffers.isDirect(arg4))
      throw new GLException("Argument \"arg4\" is not a direct buffer");
    if (!Buffers.isDirect(arg5))
      throw new GLException("Argument \"arg5\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitForSbcOML;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitForSbcOML\" not available");
    }
        return dispatch_glXWaitForSbcOML0(arg0, arg1, arg2, arg3, Buffers.getDirectBufferByteOffset(arg3), arg4, Buffers.getDirectBufferByteOffset(arg4), arg5, Buffers.getDirectBufferByteOffset(arg5), __addr_);
  }

  /** Entry point to C language function: <code> Bool glXWaitForSbcOML(Display * , XID, int64_t, int64_t * , int64_t * , int64_t * ); </code> <br>Part of <code>GLX_OML_sync_control</code>
      @param arg3 a direct only {@link java.nio.LongBuffer}
      @param arg4 a direct only {@link java.nio.LongBuffer}
      @param arg5 a direct only {@link java.nio.LongBuffer}   */
  private native boolean dispatch_glXWaitForSbcOML0(long arg0, long arg1, long arg2, Object arg3, int arg3_byte_offset, Object arg4, int arg4_byte_offset, Object arg5, int arg5_byte_offset, long procAddress);

  /** Entry point to C language function: <code> int glXWaitVideoSyncSGI(int, int, unsigned int * ); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}   */
  public int glXWaitVideoSyncSGI(int arg0, int arg1, IntBuffer arg2)  {

    if (!Buffers.isDirect(arg2))
      throw new GLException("Argument \"arg2\" is not a direct buffer");
    final long __addr_ = _context.getGLXExtProcAddressTable()._addressof_glXWaitVideoSyncSGI;
    if (__addr_ == 0) {
      throw new GLException("Method \"glXWaitVideoSyncSGI\" not available");
    }
        return dispatch_glXWaitVideoSyncSGI0(arg0, arg1, arg2, Buffers.getDirectBufferByteOffset(arg2), __addr_);
  }

  /** Entry point to C language function: <code> int glXWaitVideoSyncSGI(int, int, unsigned int * ); </code> <br>Part of <code>GLX_SGI_video_sync</code>
      @param arg2 a direct only {@link java.nio.IntBuffer}   */
  private native int dispatch_glXWaitVideoSyncSGI0(int arg0, int arg1, Object arg2, int arg2_byte_offset, long procAddress);


  // --- Begin CustomJavaCode .cfg declarations
  public GLXExtImpl(X11GLXContext context) {
    this._context = context; 
  }
  public boolean isFunctionAvailable(String glFunctionName)
  {
    return _context.isFunctionAvailable(glFunctionName);
  }
  public boolean isExtensionAvailable(String glExtensionName)
  {
    return _context.isExtensionAvailable(glExtensionName);
  }
  private X11GLXContext _context;
  // ---- End CustomJavaCode .cfg declarations

} // end of class GLXExtImpl
